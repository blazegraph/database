import java.io.File;

import net.jini.jeri.BasicILFactory;
import net.jini.jeri.BasicJeriExporter;
import net.jini.jeri.tcp.TcpServerEndpoint;

import net.jini.discovery.LookupDiscovery;
import net.jini.core.discovery.LookupLocator;
import net.jini.core.entry.Entry;
import net.jini.lookup.entry.Name;
import net.jini.lookup.entry.Comment;
import net.jini.lookup.entry.Address;
import net.jini.lookup.entry.Location;
import net.jini.lookup.entry.ServiceInfo;

import com.bigdata.util.NV;

/*
 * Declares how the service will provision itself.
 */
ServiceDescription {

	/*
	 * This object is used to export the service proxy.  The choice here effects
	 * the protocol that will be used for communications between the clients and
	 * the service.
	 *
	 * Note: specify the JVM property [-Dcom.sun.jini.jeri.tcp.useNIO=true] to enable
	 * NIO.
	 */
    exporter = new BasicJeriExporter(TcpServerEndpoint.getInstance(0),
                                     new BasicILFactory()); 
    
    /*
     * The service data directory.
     */
    dataDir = "standalone/DataServer0";
    
	/*                                          
	 * The file on which the serviceID will be written.
	 */
    serviceIdFile = new File(dataDir+"/service.id"); 
    
	/*    
	 * The name of the optional property file containing the configuration information for
	 * the service itself (where it will locate its files, etc).  When present,
	 * this file will be read and [properties] may be used to override the value
	 * read from the [propertyFile].
	 */
    // propertyFile = new File("src/resources/config/standalone/DataServer0.properties");

	/* 
	 * Optional inline properties for the service configuration.  Any values specified here
	 * will OVERRIDE any values read from the optional [propertyFile].
	 */
	properties = new NV[] {

		/*
		 * The data directory (required).  All persistent data is stored here.
		 */
		new NV("data.dir",dataDir),
		
		/*
		 * This may be used to turn off the sync to disk on commit.  This is interesting
		 * for testing and could be used when media replication provides durability, but
		 * otherwise should be left at its default value. Group commit should approximate
		 * the same performance that is observed when sync to disk on commit is disabled
		 * since it drastically increases the #of commits per sync.
		 */
		// new NV("forceOnCommit","No"),

		/* Specify [0] to the disable write cache or comment out for the default write
		 * cache capacity.
		 */
		// new NV("writeCacheCapacity","0"),
		
		/* Specify [false] to disable overflow. */
		// new NV("overflowEnabled","false"),

		// 100M initial extent.
		//new NV("initialExtent","104857600"),

		// trigger overflow early (50M)
		//new NV("initialExtent","52428800"),
		//new NV("maximumExtent","52428800"),

		// trigger overflow very early (1M)
		//new NV("initialExtent","1048576"),
		//new NV("maximumExtent","1048576"),

		// Option for StoreManager startup even if there are bad files
		// new NV("ignoreBadFiles","true"),

	};

}

/*
 * Declares how the service will advertise itself.
 */
AdvertDescription {

	/*
	 * Entry attributes used to describe the service.
	 */
    entries = new Entry[] {
                new Name("DataService0"), // human facing name.
                new ServiceInfo("bigdata", // product or package name
                        "SYSTAP,LLC", // manufacturer
                        "SYSTAP,LLC", // vendor
                        "0.1-beta", // version
                        "DataService", // model
                        "serial#" // serialNumber
                ) };

	/*
	 * Note: multicast discovery is always used if LookupDiscovery.ALL_GROUPS is
	 * specified.
	 */
//    groups = LookupDiscovery.ALL_GROUPS;
    groups = new String[]{"bigdata"};

	/*
	 * One or more unicast URIs of the form jini://host/ or jini://host:port/.
	 * This MAY be an empty array if you want to use multicast discovery _and_
	 * you have specified LookupDiscovery.ALL_GROUPS above.
	 */
    unicastLocators = new LookupLocator[] {
    	new LookupLocator("jini://localhost/")
	};    

}
