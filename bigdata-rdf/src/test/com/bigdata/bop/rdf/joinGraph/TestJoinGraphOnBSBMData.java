package com.bigdata.bop.rdf.joinGraph;

import java.io.File;
import java.util.Properties;
import java.util.UUID;

import org.openrdf.query.algebra.Compare.CompareOp;
import org.openrdf.query.algebra.MathExpr.MathOp;
import org.openrdf.rio.RDFFormat;

import com.bigdata.bop.BOp;
import com.bigdata.bop.BOpUtility;
import com.bigdata.bop.Constant;
import com.bigdata.bop.IConstraint;
import com.bigdata.bop.IPredicate;
import com.bigdata.bop.IValueExpression;
import com.bigdata.bop.IVariable;
import com.bigdata.bop.NV;
import com.bigdata.bop.Var;
import com.bigdata.bop.IPredicate.Annotations;
import com.bigdata.bop.engine.QueryLog;
import com.bigdata.bop.joinGraph.rto.JoinGraph;
import com.bigdata.journal.ITx;
import com.bigdata.journal.Journal;
import com.bigdata.rdf.internal.XSDIntIV;
import com.bigdata.rdf.internal.constraints.CompareBOp;
import com.bigdata.rdf.internal.constraints.MathBOp;
import com.bigdata.rdf.internal.constraints.NotBOp;
import com.bigdata.rdf.internal.constraints.SameTermBOp;
import com.bigdata.rdf.internal.constraints.Constraint;
import com.bigdata.rdf.model.BigdataURI;
import com.bigdata.rdf.model.BigdataValue;
import com.bigdata.rdf.model.BigdataValueFactory;
import com.bigdata.rdf.rio.LoadStats;
import com.bigdata.rdf.spo.SPOPredicate;
import com.bigdata.rdf.store.AbstractTripleStore;
import com.bigdata.rdf.store.DataLoader;
import com.bigdata.rdf.store.LocalTripleStore;
import com.bigdata.rdf.store.DataLoader.ClosureEnum;

/**
 * Unit tests for runtime query optimization using {@link JoinGraph} and the
 * "BSBM" test set.
 * <p>
 * Note: When running large queries, be sure to provide a sufficient heap, set
 * the -server flag, etc.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
public class TestJoinGraphOnBSBMData extends AbstractJoinGraphTestCase {

    /**
     * 
     */
    public TestJoinGraphOnBSBMData() {
    }

	/**
	 * @param name
	 */
	public TestJoinGraphOnBSBMData(String name) {
		super(name);
	}

	@Override
	public Properties getProperties() {

		final Properties p = new Properties(super.getProperties());

//		p.setProperty(Journal.Options.BUFFER_MODE, BufferMode.Transient
//				.toString());

//		p.setProperty(AbstractTripleStore.Options.QUADS_MODE, "true");
		
		/*
		 * Don't compute closure in the data loader since it does TM, not
		 * database at once closure.
		 */
		p.setProperty(DataLoader.Options.CLOSURE, ClosureEnum.None.toString());

		return p;

	}

	private String namespace;
	
	protected String getNamespace() {

	    return namespace;
	    
	}

    /**
     * When true, the test uses hardcoded access to an existing Journal already
     * loaded with some a larger data set (you need to run against a moderately
     * large data set to assess the relative performance of the static and
     * runtime query optimizers).
     */
	private static final boolean useExistingJournal = false;
	
//    private static final long existingPC = 284826; // BSBM 100M

     private static final long existingPC = 566496; // BSBM 200M

    private static final File existingJournal = new File("/data/bsbm/bsbm_"
            + existingPC + "/bigdata-bsbm.RW.jnl");

    /**
     * The BSBM queries are parameterized based on the data scale. This is set
     * to a product instance which exists for the scale at which this test is
     * being run.
     */
    private String productInstance;
    
    /**
     * The {@link UUID} of a {@link Journal} resource used by this test.
     */
    private static final UUID resourceId = UUID
            .fromString("cb01d320-235d-11e0-ac64-0800200c9a66");

	protected Journal getJournal(final Properties properties) throws Exception {

        final File file;
        if(useExistingJournal){
            /*
             * Use a specific file generated by some external process.
             */
            file = existingJournal;
            namespace = "BSBM_" + existingPC;
            // valid for BSBM 100M or 200M.
            productInstance = "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999";
        } else {
            /*
             * Use a persistent file that is generated once and then reused by
             * each test run.
             */
            final File tmpDir = new File(System.getProperty("java.io.tmpdir"));
            final File testDir = new File(tmpDir, "bigdata-tests");
            testDir.mkdirs();
            file = new File(testDir, resourceId + ".jnl");
            namespace = "BSBM_100";
            // valid for BSBM 100
            productInstance = "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1/Product22";
        }
        
        properties.setProperty(Journal.Options.FILE, file.toString());

//      properties.setProperty(Journal.Options.BUFFER_MODE,BufferMode.DiskRW.toString());

//      file.delete();

        if (!file.exists()) {

            final Journal jnl = new Journal(properties);

            final String resource = "bigdata-rdf/src/resources/data/bsbm/dataset_pc100.nt";

            final AbstractTripleStore tripleStore = new LocalTripleStore(jnl,
                    namespace, ITx.UNISOLATED, getProperties());

            // Create the KB instance.
            tripleStore.create();

            // Load data.
            final LoadStats loadStats = tripleStore.getDataLoader().loadData(
                    resource, "file:" + resource, RDFFormat.N3);
            
            if (log.isInfoEnabled())
                log.info(loadStats.toString());

            // Truncate the journal (trim its size).
            jnl.truncate();

            // Commit the journal.
            jnl.commit();

            // Close the journal.
            jnl.close();
        }

        // Open the test resource.
        return new Journal(properties);

	}

    /**
     * BSBM Q5
     * 
     * <pre>
     * PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
     * PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
     * PREFIX bsbm: <http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/vocabulary/>
     * 
     * SELECT DISTINCT ?product ?productLabel
     * WHERE { 
     *     ?product rdfs:label ?productLabel .
     *     FILTER (<http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999> != ?product)
     *     <http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999> bsbm:productFeature ?prodFeature .
     *     ?product bsbm:productFeature ?prodFeature .
     *     <http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999> bsbm:productPropertyNumeric1 ?origProperty1 .
     *     ?product bsbm:productPropertyNumeric1 ?simProperty1 .
     *     FILTER (?simProperty1 < (?origProperty1 + 120) && ?simProperty1 > (?origProperty1 - 120))
     *     <http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999> bsbm:productPropertyNumeric2 ?origProperty2 .
     *     ?product bsbm:productPropertyNumeric2 ?simProperty2 .
     *     FILTER (?simProperty2 < (?origProperty2 + 170) && ?simProperty2 > (?origProperty2 - 170))
     * }
     * ORDER BY ?productLabel
     * LIMIT 5
     * </pre>
     * 
     * Note: There are two predicates which bind variables (origProperty1 and
     * origProperty2) that are not used by the other predicates and therefore do
     * not share any variables which would form "edges" that define joins. In
     * general, a join without shared variables means the cross product of the
     * sources will be materialized and such joins should be run last.
     * <p>
     * However, in this case there are SPARQL FILTERs which (a) use those
     * variables (origProperty1 and origProperty2); and (b) can constrain the
     * query. This means that running the predicates without shared variables
     * and applying the constraints before the tail of the plan can in fact lead
     * to a more efficient join path.
     */
	@SuppressWarnings("unchecked")
    public void test_bsbm_q5() throws Exception {

		QueryLog.logTableHeader();
		
	    final String namespace = getNamespace();
	    
	    final AbstractTripleStore database = getDatabase(namespace);
	    
		/*
		 * Resolve terms against the lexicon.
		 */
		final BigdataValueFactory valueFactory = database.getLexiconRelation()
				.getValueFactory();

        final String rdfs = "http://www.w3.org/2000/01/rdf-schema#";
//        final String rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        final String bsbm = "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/vocabulary/";

//        final BigdataURI rdfType = valueFactory.createURI(rdf + "type");

        final BigdataURI rdfsLabel = valueFactory.createURI(rdfs + "label");

        final BigdataURI productFeature = valueFactory.createURI(bsbm
                + "productFeature");

        final BigdataURI productPropertyNumeric1 = valueFactory.createURI(bsbm
                + "productPropertyNumeric1");

        final BigdataURI productPropertyNumeric2 = valueFactory.createURI(bsbm
                + "productPropertyNumeric2");

        final BigdataURI product53999 = valueFactory.createURI(productInstance);
		
        final BigdataValue[] terms = new BigdataValue[] { rdfsLabel,
                productFeature, productPropertyNumeric1,
                productPropertyNumeric2, product53999 };

		// resolve terms.
		database.getLexiconRelation()
				.addTerms(terms, terms.length, true/* readOnly */);

		{
			for (BigdataValue tmp : terms) {
				System.out.println(tmp + " : " + tmp.getIV());
				if (tmp.getIV() == null)
					throw new RuntimeException("Not defined: " + tmp);
			}
		}

		final IConstraint[] constraints;
		final IPredicate[] preds;
		final IPredicate p0, p1, p2, p3, p4, p5, p6;
		{
		    final IVariable product = Var.var("product");
		    final IVariable productLabel = Var.var("productLabel"); 
            final IVariable prodFeature = Var.var("prodFeature");
		    final IVariable simProperty1 = Var.var("simProperty1"); 
		    final IVariable simProperty2 = Var.var("simProperty2"); 
		    final IVariable origProperty1 = Var.var("origProperty1"); 
		    final IVariable origProperty2 = Var.var("origProperty2"); 

			// The name space for the SPO relation.
			final String[] spoRelation = new String[] { namespace + ".spo" };

//			// The name space for the Lexicon relation.
//			final String[] lexRelation = new String[] { namespace + ".lex" };

			final long timestamp = database.getIndexManager().getLastCommitTime();

			int nextId = 0;

//			?product rdfs:label ?productLabel .
			p0 = new SPOPredicate(new BOp[] {//
			        product,
					new Constant(rdfsLabel.getIV()),
					productLabel//
					},//
					new NV(BOp.Annotations.BOP_ID, nextId++),//
					new NV(Annotations.TIMESTAMP, timestamp),//
					new NV(IPredicate.Annotations.RELATION_NAME, spoRelation)//
			);
						
//          <http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999> bsbm:productFeature ?prodFeature .
			p1 = new SPOPredicate(new BOp[] { //
			        new Constant(product53999.getIV()),//
                    new Constant(productFeature.getIV()),//
                    prodFeature//
                    },//
                    new NV(BOp.Annotations.BOP_ID, nextId++),//
                    new NV(Annotations.TIMESTAMP, timestamp),//
                    new NV(IPredicate.Annotations.RELATION_NAME, spoRelation)
			);
			
//          ?product bsbm:productFeature ?prodFeature .
            p2 = new SPOPredicate(new BOp[] { //
                    product,//
                    new Constant(productFeature.getIV()),//
                    prodFeature//
                    },//
                    new NV(BOp.Annotations.BOP_ID, nextId++),//
                    new NV(Annotations.TIMESTAMP, timestamp),//
                    new NV(IPredicate.Annotations.RELATION_NAME, spoRelation)
            );
            
//          <http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999> bsbm:productPropertyNumeric1 ?origProperty1 .
            p3 = new SPOPredicate(new BOp[] { //
                    new Constant(product53999.getIV()),//
                    new Constant(productPropertyNumeric1.getIV()),//
                    origProperty1//
                    },//
                    new NV(BOp.Annotations.BOP_ID, nextId++),//
                    new NV(Annotations.TIMESTAMP, timestamp),//
                    new NV(IPredicate.Annotations.RELATION_NAME, spoRelation)
            );
            
//          ?product bsbm:productPropertyNumeric1 ?simProperty1 .
            p4 = new SPOPredicate(new BOp[] { //
                    product,//
                    new Constant(productPropertyNumeric1.getIV()),//
                    simProperty1//
                    },//
                    new NV(BOp.Annotations.BOP_ID, nextId++),//
                    new NV(Annotations.TIMESTAMP, timestamp),//
                    new NV(IPredicate.Annotations.RELATION_NAME, spoRelation)//
            );

//          <http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer1092/Product53999> bsbm:productPropertyNumeric2 ?origProperty2 .
            p5 = new SPOPredicate(new BOp[] { //
                    new Constant(product53999.getIV()),//
                    new Constant(productPropertyNumeric2.getIV()),//
                    origProperty2//
                    },//
                    new NV(BOp.Annotations.BOP_ID, nextId++),//
                    new NV(Annotations.TIMESTAMP, timestamp),//
                    new NV(IPredicate.Annotations.RELATION_NAME, spoRelation)
            );

//          ?product bsbm:productPropertyNumeric2 ?simProperty2 .
            p6 = new SPOPredicate(new BOp[] { //
                    product,//
                    new Constant(productPropertyNumeric2.getIV()),//
                    simProperty2//
                    },//
                    new NV(BOp.Annotations.BOP_ID, nextId++),//
                    new NV(Annotations.TIMESTAMP, timestamp),//
                    new NV(IPredicate.Annotations.RELATION_NAME, spoRelation)//
            );

            // the vertices of the join graph (the predicates).
            preds = new IPredicate[] { p0, p1, p2, p3, p4, p5, p6 };

            final IValueExpression[] ves = new IValueExpression[] {

                    /*
                     * FILTER
                     * (<http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances
                     * /dataFromProducer1092/Product53999> != ?product)
                     */
                    new NotBOp(new SameTermBOp(product, new Constant(product53999.getIV()))), //

                    /*
                     * FILTER (?simProperty1 < (?origProperty1 + 120) &&
                     * ?simProperty1 > (?origProperty1 - 120))
                     * 
                     * Note: The AND in the compound filters is typically
                     * optimized out so each of these is represented as its own
                     * IConstraint.
                     */
                    new CompareBOp(new BOp[] {
                            simProperty1,
                            new MathBOp(origProperty1, new Constant(
                                    new XSDIntIV(120)), MathOp.PLUS) }, NV
                            .asMap(new NV[] { new NV(CompareBOp.Annotations.OP,
                                    CompareOp.LT) })),//

                    new CompareBOp(new BOp[] {
                            simProperty1,
                            new MathBOp(origProperty1, new Constant(
                                    new XSDIntIV(120)), MathOp.MINUS) }, NV
                            .asMap(new NV[] { new NV(CompareBOp.Annotations.OP,
                                    CompareOp.GT) })),//

                    /*
                     * FILTER (?simProperty2 < (?origProperty2 + 170) &&
                     * ?simProperty2 > (?origProperty2 - 170))
                     */
                    new CompareBOp(new BOp[] {
                            simProperty2,
                            new MathBOp(origProperty2, new Constant(
                                    new XSDIntIV(170)), MathOp.PLUS) }, NV
                            .asMap(new NV[] { new NV(CompareBOp.Annotations.OP,
                                    CompareOp.LT) })),//

                    new CompareBOp(new BOp[] {
                            simProperty2,
                            new MathBOp(origProperty2, new Constant(
                                    new XSDIntIV(170)), MathOp.MINUS) }, NV
                            .asMap(new NV[] { new NV(CompareBOp.Annotations.OP,
                                    CompareOp.GT) })),//

            };
            
            // the constraints on the join graph.
            constraints = new IConstraint[ves.length];
            for (int i = 0; i < ves.length; i++) {
            	constraints[i] = Constraint.wrap(ves[i]);
            }

        }

        /*
         * Run w/o constraints.
         * 
         * Note: There are no solutions for this query against BSBM 100. The
         * optimizer is only providing the fastest path to prove that. We have
         * to use a larger data set if we want to verify the optimizers join
         * path for a query which produces solutions in the data.
         */
        if (false) {
            final IPredicate<?>[] runtimeOrder = doTest(preds, null/* constraints */);
            /*
             * Verify that the runtime optimizer produced the expected join
             * path.
             * 
             * Note: The optimizer finds the same join path for the BSBM 100,
             * 100M, and 200M data sets
             */
            assertEquals("runtimeOrder", new int[] { 1, 2, 0, 4, 6, 3, 5 },
                    BOpUtility.getPredIds(runtimeOrder));
        }

        /*
         * Run w/ constraints.
         */
        if(true){

            final IPredicate<?>[] runtimeOrder = doTest(preds, constraints);
            
            /*
             * Verify that the runtime optimizer produced the expected join
             * path.
             *
             * FIXME Figure out what the right query is.
             */
            assertEquals("runtimeOrder", new int[] { 1, 2, 0, 4, 6, 3, 5 },
                    BOpUtility.getPredIds(runtimeOrder));
        }
        
    }

}
