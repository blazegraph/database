/**

Copyright (C) SYSTAP, LLC 2006-2007.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package com.bigdata.rdf.lexicon;

import com.bigdata.btree.ICounter;
import com.bigdata.btree.BTree.PartitionedCounter;

/**
 * An encoder/decoder for long values formed from a partition identifier in
 * the high word and a local counter in the low word where (1) the sign bit
 * is stolen from both the local counter and the partition identifier; and
 * then (2) the low N bits of the long value are reversed and rotated into
 * the high N bits of the long value. The stolen sign bits are made
 * available for bit flags in the low two-bits of the resulting long value
 * (they will be ZERO(0) and may be overwritten by the caller).
 * <p>
 * The purpose of this encoding is to cause the N high bits to vary rapily
 * as the local counter is driven up by writes on the index partition. This
 * has the effect of scattering writes on dependent indices (those using the
 * resulting long value as the sole or leading component of their key).
 * <p>
 * Given a source RDF/XML document with M "terms" distributed uniformly over
 * K TERM2ID index partitions, each term has a uniform likelyhood of setting
 * any of the low bits of the local counter. After encoding, this means that
 * the N high-bits of encoded term identifier are uniformly distributed.
 * Assuming that the separator keys for the ID2TERM index divide the key
 * space into equally sized key-ranges, then the reads and writes on the
 * ID2TERM index partitions will be uniformly distributed as well.
 * <p>
 * The next bits in the encoded values are derived from the partition
 * identifer followed by the term identifier and therefore have a strong
 * bias for the index partition and the sequential assignment of local
 * counter values within an index partition respectively. This means that
 * read / write access within an index partition tends to have some
 * locality, which improves B+Tree performance through several mechanisms
 * (mainly improved cache effects, reduced copy-on-write for dirty leaves
 * and nodes, and less IO costs).
 * <p>
 * When the #of ID2TERM index partitions GT 2^N, only a subset of those
 * index partitions can be directly selected by the N high bits with their
 * uniform distribution. The next bias is the partition identifier, which
 * begins at ZERO (0), is inflated to (0, [1:P]), where P is the #of index
 * partitions generated by a scatter split, and grows relatively slowly
 * thereafter as index partitions are fill up and are split or are moved to
 * redistribute the load on the cluster.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
public class TermIdEncoder {

    /**
     * The #of low bits from the local counter that will be reversed and
     * written into the high-bits of the encoded long value.
     */
    private final int N;

    /**
     * A mask with the {@link #N} low bits turned on. 
     */
    private final int mask;

    public String toString() {

        return getClass().getName() + "{N=" + N + ", mask="
                + Integer.toBinaryString(mask) + "}";

    }

    public TermIdEncoder(final int N) {

        if (N < 0)
            throw new IllegalArgumentException();

        if (N > 31)
            throw new IllegalArgumentException();

        this.N = N;

        /*
         * Construct the bit mask - this will have zeros in the high bits
         * that correspond to the bits of the localCounter that WILL NOT be
         * reversed and ones in the low bits that correspond to bits of the
         * localCounter that WILL be reversed.
         */
        {

            int mask = 0;

            int bit;

            for (int i = 0; i < N; i++) {

                bit = (1 << i);

                mask |= bit;

            }

            this.mask = mask;

        }

    }

    /**
     * 
     * @param v
     *            A 64-bit long counter value as generated by an
     *            {@link ICounter}.
     * 
     * @return A permutation of that long value in which the sign bits have
     *         been "stolen" and the low <i>N</i> bits have been reversed
     *         and rotated into the high <i>N</i> bits. The low 2 bits are
     *         unassigned (these were the sign bits of the partition
     *         identifier and the local counter and hence were known to be
     *         ZERO(0)) and may be used as bit flags.
     */
    public long encode(final long v) {

        // the partition identifier.
        final int pid = getPartitionId(v);
        if (pid < 0) {
            // must be non-negative.
            throw new IllegalArgumentException("pid is negative: " + pid);
        }

        // the local counter.
        final int ctr = getLocalCounter(v);
        if (ctr <= 0) {
            // must be positive (0 reserved for NULL).
            throw new IllegalArgumentException("ctr is not positive: " + ctr);
        }

        /*
         * Note: If you want to modify this to use all bits rather than
         * stealing the sign bits then look at the (N-1) term and the << 2
         * term, both of which are involved in stealing the sign bits.
         */

        // the output value.
        long u = 0L;

        /*
         * Move pid to high word. The high bit of the pid is the sign bit.
         * The sign bit is zero and will be overwritten by the reverse low N
         * bits of the ctr. Therefore we left shift by 32-(N-1) so that the
         * high bit of the pid winds up in the low bit of the N-bit field
         * where it will be overwritten.
         */
        u |= ((long) pid) << (32 - (N - 1));

        /*
         * Right shift the counter over the bits that are being reversed,
         * extend to a long value, and then then left shift the long value
         * to make room for the 2 flag bits.
         */
        u |= (((long) (ctr >>> N)) << 2);

        /*
         * Use the mask to isolate the low-N bits of the counter, which are
         * then reversed into the high-N bits.
         */
        final int rev = Integer.reverse(ctr & mask);

        /*
         * Overwrite the high N bits of the long value using the reversed
         * low N bits from the local counter.
         */
        u |= ((long) rev) << 32;

        return u;

    }

    /**
     * Reverses the effect of {@link #encode(long)}.
     * 
     * @param u
     *            An encoded long value.
     * 
     * @return The decode long value.
     */
    public long decode(final long u) {

        /*
         * Note: If you want to modify this to use all bits rather than
         * stealing the sign bits then look at the (N-1) term and the >>> 2
         * term, both of which are involved in stealing the sign bits.
         */

        // reverse high word and mask to recover the low-N bits.
        final int fwd = Integer.reverse(((int) (u >>> 32))) & mask;

        /*
         * Shift down the long value to cover up the flag bits and then
         * left-shift the make room for the (un-)reversed bits. Mask off the
         * high-bit since the sign bit of the local counter is always zero
         * but it was overwritten by the low bit of the partition identifier
         * so we need to clear it to zero when we decode it.
         */
        final int ctr = ((int) ((u >>> 2) << N) | fwd) & 0x7fffffff;

        /*
         * Bring the partition identifier back to an int by shifting it the
         * same number of bits in the other direction and masking off the
         * high bit since the sign bit is always zero and if can be non-zero
         * if we don't mask it off since it was overwritten by the reversed
         * low bits from the counter.
         */
        final int pid = ((int) (u >>> (32 - (N - 1)))) & 0x7fffffff;

        // reconstruct the long counter value.
        return ((long) (pid) << 32) | ctr;

    }

    /**
     * Return the partition identifier from the high word of a partitioned
     * counter.
     * 
     * @param v
     *            The partitioned counter.
     * 
     * @return The high word.
     */
    public static int getPartitionId(final long v) {

        return (int) (v >>> 32);

    }

    /**
     * Return the local counter from the low word of a partitioned counter.
     * 
     * @param v
     *            The partitioned counter.
     * 
     * @return The low word.
     */
    public static int getLocalCounter(final long v) {

        return (int) v;

    }

    /**
     * Combines the partition identifier and the local counter using the
     * same logic as the {@link PartitionedCounter}.
     * 
     * @param pid
     *            The partition identifier.
     * @param ctr
     *            The local counter.
     *            
     * @return The long counter assembled from those values.
     */
    public static long combine(final int pid, final int ctr) {

        return ((long) pid) << 32 | ctr;

    }

    /**
     * Set the bit flags for the Value type on the 2 low order bits.
     * 
     * @param id
     *            The encoded term identifier.
     * @param code
     *            The term code, which is one of the values defined by
     *            {@link ITermIndexCodes}.
     * 
     * @return The term identifier with the 2 low order bits set to reflect
     *         the term code using the bit flags defined by
     *         {@link ITermIdCodes} which correspond to the specified term
     *         code.
     */
    public static long setFlags(long id, final byte code) {

        switch (code) {

        case ITermIndexCodes.TERM_CODE_URI:

            id |= ITermIdCodes.TERMID_CODE_URI;

            break;

        case ITermIndexCodes.TERM_CODE_LIT:
        case ITermIndexCodes.TERM_CODE_DTL:
        case ITermIndexCodes.TERM_CODE_LCL:

            id |= ITermIdCodes.TERMID_CODE_LITERAL;

            break;

        case ITermIndexCodes.TERM_CODE_BND:

            id |= ITermIdCodes.TERMID_CODE_BNODE;

            break;

        case ITermIndexCodes.TERM_CODE_STMT:

            id |= ITermIdCodes.TERMID_CODE_STATEMENT;

            break;

        default:

            throw new AssertionError("Unknown term type: code=" + code);

        }

        return id;

    }

}
