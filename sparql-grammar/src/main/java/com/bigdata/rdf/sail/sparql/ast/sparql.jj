/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. sparql.jj */
/*@egen*//**

Copyright (C) SYSTAP, LLC DBA Blazegraph 2006-2016.  All rights reserved.

Contact:
     SYSTAP, LLC DBA Blazegraph
     2501 Calvert ST NW #106
     Washington, DC 20008
     licenses@blazegraph.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
/* @author: Bryan Thompson
 * @openrdf
 *
 * "make javacc" to rebuild.  Be sure to first remove the sparql.jj file
 * so it will generate a new one.
 * 
 * Updated 6/7/14 by Mike Personick.  Updated to capture the delta between the 
 * Sesame 2.6.10/2.7.12 sparql.jjt files.
 */
 
/*
 * Copyright Aduna (http://www.aduna-software.com/) (c) 1997-2007.
 *
 * Licensed under the Aduna BSD-style license.
 */

/*
 * SPARQL JJTree input file for JavaCC, a Java Compiler Compiler. JavaCC can be
 * downloaded from https://javacc.dev.java.net/
 *
 * author: Arjohn Kampman
 */

options {
               
                 
                                         
    STATIC=false;
    UNICODE_INPUT=true;
    JAVA_UNICODE_ESCAPE=true; // pre-process unicode escapes, see section A.2 of spec
}

PARSER_BEGIN(SyntaxTreeBuilder)

package com.bigdata.rdf.sail.sparql.ast;

import java.io.StringReader;

import org.openrdf.model.URI;
import org.openrdf.model.vocabulary.RDF;
import org.openrdf.model.vocabulary.XMLSchema;
import org.openrdf.query.algebra.Compare.CompareOp;
import org.openrdf.query.algebra.MathExpr.MathOp;
import org.openrdf.rio.RDFParser.DatatypeHandling;

public class SyntaxTreeBuilder/*@bgen(jjtree)*/implements SyntaxTreeBuilderTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSyntaxTreeBuilderState jjtree = new JJTSyntaxTreeBuilderState();

/*@egen*/

    /**
     * Parses the supplied SPARQL query and builds a syntax tree from it.
     *
     * @param query A SPARQL query string.
     * @return The root of the syntax tree.
     * @throws TokenMgrError If the query was syntactically incorrect.
     * @throws ParseException If the query was syntactically incorrect.
     */
    public static ASTQueryContainer parseQuery(final String query)
        throws TokenMgrError, ParseException
    {
        final SyntaxTreeBuilder stb = new SyntaxTreeBuilder( new StringReader(query) );

        // Set size of tab to 1 to force tokenmanager to report correct column
        // index for substring splitting of service graph pattern.
        stb.jj_input_stream.setTabSize(1);

        final ASTQueryContainer container = stb.QueryContainer();
        container.setSourceString(query);
        return container;
    }

    /**
     * Parses the supplied SPARQL update sequence and builds a syntax tree from it.
     *
     * @param sequence A SPARQL update sequence string.
     * @return The root of the syntax tree.
     * @throws TokenMgrError If the update sequence was syntactically incorrect.
     * @throws ParseException If the update sequence was syntactically incorrect.
     */
    public static ASTUpdateSequence parseUpdateSequence(final String sequence)
        throws TokenMgrError, ParseException
    {
        final SyntaxTreeBuilder stb = new SyntaxTreeBuilder( new StringReader(sequence) );
        final ASTUpdateSequence seq = stb.UpdateSequence();
        seq.setSourceString(sequence);
        return seq;
    }
    
    /**
     * Trims <tt>n</tt> character from the start and end of the supplied string.
     */
    private static String _trimString(String s, int n) {
        if (s.length() >= 2 * n) {
            s = s.substring(n, s.length() - n);
        }
        return s;
    }

	private String readToMatchingBrace() {
	    StringBuilder sb = new StringBuilder();
	    Token tok;
	    int nesting = 1;
	    boolean previousTokenDtSep = false;
	    while (true) {
		tok = getToken(1);
		if (!previousTokenDtSep && ! tok.image.equals("^^") && !tok.image.startsWith("@")) {
		    sb.append(" ");
		}
		if (tok.kind == LBRACE) nesting++;
		if (tok.kind == RBRACE) {
		    nesting--;
		    if (nesting == 0) break;
		}
		// To provide correct line numbers (see https://jira.blazegraph.com/browse/BLZG-1397)
		// we should keep line breaks and one-line comments. So, we are adding special tokens
		// (comments and and new line char) per https://javacc.java.net/doc/tokenmanager.html

		if (tok.specialToken != null) {
			// The above statement determines that there is a special token
			Token tmp_t = tok.specialToken;
			while (tmp_t.specialToken != null)
				tmp_t = tmp_t.specialToken;
			// The above line walks back the special token chain until it
			// reaches the first special token after the previous regular
			// token.
			while (tmp_t != null) {
				sb.append(tmp_t.image);
				tmp_t = tmp_t.next;
			}
			// The above loop now walks the special token chain in the forward
			// direction printing them in the process.
		}
		sb.append(tok.image);
		previousTokenDtSep = tok.image.equals("^^");

		tok = getNextToken();

	    }
	    return sb.toString();
	}
}
PARSER_END(SyntaxTreeBuilder)

//
// tokens
//

TOKEN :
{
    // Whitespace characters
    <#WS_CHAR: " " | "\t" | "\r" | "\f">
}

SKIP :
{
    <WHITESPACE: <WS_CHAR>>
}

SPECIAL_TOKEN :
{
    <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])*>
|   <NEW_LINE: "\n">
}

// Special characters
TOKEN :
{
    <LPAREN: "(">
|   <RPAREN: ")">
|   <LBRACE: "{">
|   <RBRACE: "}">
|   <LBRACK: "[">
|   <RBRACK: "]">
|   <SEMICOLON: ";">
|   <COMMA: ",">
|   <DOT: ".">
|   <EQ: "=">
|   <NE: "!=">
|   <GT: ">">
|   <LT: "<">
|   <LE: "<=">
|   <GE: ">=">
|   <NOT: "!">
|   <OR: "||">
|   <AND: "&&">
|   <PLUS: "+">
|   <MINUS: "-">
|   <STAR: "*">
|   <QUESTION: "?">
|   <SLASH: "/">
|       <PIPE: "|">
|   <INVERSE: "^">
|   <DT_PREFIX: "^^">
|   <NIL: <LPAREN> (<WS_CHAR>|<NEW_LINE>)* <RPAREN>>
|   <ANON: <LBRACK> (<WS_CHAR>|<NEW_LINE>)* <RBRACK>>
}

TOKEN :
{
    <IS_A: "a"> // Note: case-sensitive!
}

TOKEN [IGNORE_CASE] :
{
    <BASE: "base">
|   <PREFIX: "prefix">
|   <SELECT: "select">
|   <CONSTRUCT: "construct">
|   <DESCRIBE: "describe">
|   <ASK: "ask">
|   <DISTINCT: "distinct">
|   <REDUCED: "reduced">
|   <AS: "as">
|   <FROM: "from">
|   <NAMED: "named">
|   <WHERE: "where">
|   <ORDER: "order">
|   <GROUP: "group">
|   <BY: "by">
|   <ASC: "asc">
|   <DESC: "desc">
|   <LIMIT: "limit">
|   <OFFSET: "offset">
|   <OPTIONAL: "optional">
|   <GRAPH: "graph">
|   <UNION: "union">
|   <MINUS_SETOPER: "minus">
|   <FILTER: "filter">
|   <HAVING: "having">
|   <EXISTS: "exists">
|   <NOT_EXISTS: "not exists">
|   <STR: "str">
|   <LANG: "lang">
|   <LANGMATCHES: "langmatches">
|   <DATATYPE: "datatype">
|   <BOUND: "bound">
|   <SAMETERM: "sameTerm">
|   <IS_IRI: ("isIRI"|"isURI")>
|   <IS_BLANK: "isBlank">
|   <IS_LITERAL: "isLiteral">
|   <IS_NUMERIC: "isNumeric">
|   <COALESCE: "coalesce">
|   <BNODE: "bnode">
|   <STRDT: "strdt">
|   <STRLANG: "strlang">
|	<UUID: "uuid">
|	<STRUUID: "struuid">
|   <IRI: "IRI"|"URI">
|   <IF: "if">
|   <IN: "in">
|   <NOT_IN: "not in">
|   <COUNT: "count">
|   <SUM: "sum">
|   <MIN: "min">
|   <MAX: "max">
|   <AVG: "avg">
|   <SAMPLE: "sample">
|   <GROUP_CONCAT: "group_concat">
|   <SEPARATOR: "separator">
|   <REGEX: "regex">
|   <TRUE: "true">
|   <FALSE: "false">
|   <BIND: "bind">
|   <SERVICE: "service">
|   <BINDINGS: "bindings">
|	<VALUES: "values">
|   <UNDEF: "UNDEF">
|   <STRLEN: "strlen">
|   <SUBSTR: "substr">
|   <STR_STARTS: "strStarts">
|   <STR_ENDS: "strEnds">
|   <STR_BEFORE: "strBefore">
|   <STR_AFTER: "strAfter">
|   <REPLACE: "replace">
|   <UCASE: "ucase">
|   <LCASE: "lcase">
|   <CONCAT: "concat">
|   <CONTAINS: "contains">
|   <ENCODE_FOR_URI: "encode_for_URI">
|   <RAND: "rand">
|   <ABS: "abs">
|   <CEIL: "ceil">
|   <FLOOR: "floor">
|   <ROUND: "round">
|   <NOW: "now">
|   <YEAR: "year">
|   <MONTH: "month">
|   <DAY: "day">
|   <HOURS: "hours">
|   <MINUTES: "minutes">
|   <SECONDS: "seconds">
|   <TIMEZONE: "timezone">
|   <TZ: "tz">
|   <MD5: "md5">
|   <SHA1: "sha1">
|   <SHA224: "sha224">
|   <SHA256: "sha256">
|   <SHA384: "sha384">
|   <SHA512: "sha512">
}

TOKEN [IGNORE_CASE] :   // Bigdata extension specific tokens
{
    <INCLUDE: "include">
|   <LET: "let">
|   <ASSIGN: ":=">
|   <VAR3: "%" <VARNAME>>
|   <VIRTUAL_GRAPH: "virtual graph">
|   <GRAPHS: "graphs">
|   <SOLUTIONS: "solutions">
|   <TREF_OPEN: "<<">
|   <TREF_CLOSE: ">>">
// RDFParserOptions (for LOAD)
|   <VERIFY_DATA: "verifyData">
|   <PRESERVE_BNODE_IDS: "preserveBNodeIDs">
|   <STOP_AT_FIRST_ERROR: "stopAtFirstError">
|   <DATATYPE_HANDLING: "datatypeHandling">
|   <VERIFY: "VERIFY">
|   <IGNORE: "IGNORE">
|   <NORMALIZE: "NORMALIZE">
// Managing Truth Maintenance
|   <DROP_ENTAILMENTS: "drop entailments">
|   <CREATE_ENTAILMENTS: "create entailments">
|   <ENABLE_ENTAILMENTS: "enable entailments">
|   <DISABLE_ENTAILMENTS: "disable entailments">
}

TOKEN [IGNORE_CASE] :   // SPARQL 1.1 Update-specific tokens
{
    <LOAD: "load">
|   <CLEAR: "clear">
|   <DROP: "drop">
|   <ADD: "add">
|   <MOVE: "move">
|   <COPY: "copy">
|   <CREATE: "create">
|   <INSERT: "insert">
|   <DATA: "data">
|   <DELETE: "delete">
|   <WITH: "with">
|   <SILENT: "silent">
|   <DEFAULT_GRAPH: "default">
|   <ALL: "all">
|   <INTO: "into">
|   <TO: "to">
|   <USING: "using">
}

TOKEN:
{
    <Q_IRI_REF: "<" (~["<", ">", "\"", "{", "}", "|", "^", "`", "\\", "\u0000"-" "])* ">">

|   <PNAME_NS: (<PN_PREFIX>)? ":">
|   <PNAME_LN: (<PN_PREFIX>)? ":" <PN_LOCAL>> // Note: PN_LOCAL not optional, case handled by PNAME_NS
|	<BLANK_NODE_LABEL: "_:" (<PN_CHARS_U> | <NUM>) ((<PN_CHARS>|".")* <PN_CHARS>)? >
|   <VAR1: "?" <VARNAME>>
|   <VAR2: "$" <VARNAME>>
|   <LANGTAG: "@" (<ALPHA>)+ ("-" (<ALPHA>|<NUM>)+)*>
|   <INTEGER: (<NUM>)+>
|   <INTEGER_POSITIVE: "+" <INTEGER>>
|   <INTEGER_NEGATIVE: "-" <INTEGER>>
|   <DECIMAL: (<DECIMAL1>|<DECIMAL2>)>
|   <#DECIMAL1: (<NUM>)+ "." (<NUM>)*>
|   <#DECIMAL2: "." (<NUM>)+>
|   <DECIMAL_POSITIVE: "+" <DECIMAL>>
|   <DECIMAL_NEGATIVE: "-" <DECIMAL>>
|   <DOUBLE: (<DOUBLE1>|<DOUBLE2>|<DOUBLE3>)>
|   <#DOUBLE1: (<NUM>)+ "." (<NUM>)* <EXPONENT>>
|   <#DOUBLE2: "." (<NUM>)+ <EXPONENT>>
|   <#DOUBLE3: (<NUM>)+ <EXPONENT>>
|   <#EXPONENT: ["e","E"] (["+","-"])? (<NUM>)+>
|   <DOUBLE_POSITIVE: "+" <DOUBLE>>
|   <DOUBLE_NEGATIVE: "-" <DOUBLE>>
|   <STRING_LITERAL1: "'" (<SAFE_CHAR1>|<ECHAR>)* "'">
|   <STRING_LITERAL2: "\"" (<SAFE_CHAR2>|<ECHAR>)* "\"">
|   <STRING_LITERAL_LONG1: "'''" ( ("'"|"''")? (<SAFE_CHAR_LONG1>|<ECHAR>) )* "'''">
|   <STRING_LITERAL_LONG2: "\"\"\"" ( ("\""|"\"\"")? (<SAFE_CHAR_LONG2>|<ECHAR>) )* "\"\"\"">
|   <#SAFE_CHAR1: (~["'", "\\", "\r", "\n"])>
|   <#SAFE_CHAR2: (~["\"", "\\", "\r", "\n"])>
|   <#SAFE_CHAR_LONG1: (~["'","\\"])>
|   <#SAFE_CHAR_LONG2: (~["\"","\\"])>
|   <#ECHAR: "\\" ["t", "b", "n", "r", "f", "\\", "\"", "'"]>
|   <#HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
|   <#ALPHA: ["a"-"z","A"-"Z"]>
|   <#NUM: ["0"-"9"]>
}

TOKEN:
{
    <#PN_CHARS_BASE:
        <ALPHA> | ["\u00c0"-"\u00d6"] | ["\u00d8"-"\u00f6"] | ["\u00f8"-"\u02ff"] | ["\u0370"-"\u037d"]
      | ["\u037f"-"\u1fff"] | ["\u200c"-"\u200d"] | ["\u2070"-"\u218f"] | ["\u2c00"-"\u2fef"]
      | ["\u3001"-"\ud7ff"] | ["\uf900"-"\ufdcf"] | ["\ufdf0"-"\ufffd"]
      // | ["\u10000"-"\uefffF"] FIXME: JavaCC/Java can't handle this?
    >
|   <#PN_CHARS_U: <PN_CHARS_BASE> | "_">
|	<#VAR_CHAR: <PN_CHARS_U> | <NUM> | "\u00b7" | ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"]>
|	<#PN_CHARS: <PN_CHARS_U> | "-" | <NUM> | "\u00b7" | ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"]> 
|	<#PN_PREFIX: <PN_CHARS_BASE> ( (<PN_CHARS> | ".")* <PN_CHARS>)?>
|	<#PN_LOCAL: (<PN_CHARS_U> | ":" | <NUM> | <PLX> ) ( (<PN_CHARS> | "." | ":" | <PLX>)* ( <PN_CHARS> | ":" | <PLX>) )?>
|   <#PLX: <PERCENT> | <PN_LOCAL_ESC>>
|   <#PERCENT: "%" <HEX> <HEX>>
|	<#PN_LOCAL_ESC: "\\" [ "_", "~", ".", "-", "!", "$", "&", "\"", "(", ")", "*", "+", ",", ";", "=", "/", "?", "#", "@", "%" ]>
|	<#VARNAME: (<PN_CHARS_U> | <NUM> ) (<VAR_CHAR>)*>
}

//
// grammar
//

ASTUpdateSequence UpdateSequence():
{/*@bgen(jjtree) UpdateSequence */
  ASTUpdateSequence jjtn000 = new ASTUpdateSequence(JJTUPDATESEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UpdateSequence */
    try {
/*@egen*/
    UpdateContainer() [ <SEMICOLON> UpdateSequence() ] <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTUpdateContainer UpdateContainer():
{/*@bgen(jjtree) UpdateContainer */
  ASTUpdateContainer jjtn000 = new ASTUpdateContainer(JJTUPDATECONTAINER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UpdateContainer */
    try {
/*@egen*/
    Prolog() [ Update() ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTQueryContainer QueryContainer():
{/*@bgen(jjtree) QueryContainer */
  ASTQueryContainer jjtn000 = new ASTQueryContainer(JJTQUERYCONTAINER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) QueryContainer */
    try {
/*@egen*/
    Prolog() Query() <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Prolog()       :
{}
{
    ( PrefixDecl() | BaseDecl() )*
}

void BaseDecl() :
{/*@bgen(jjtree) BaseDecl */
  ASTBaseDecl jjtn000 = new ASTBaseDecl(JJTBASEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) BaseDecl */
    try {
/*@egen*/
    <BASE> t = <Q_IRI_REF>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {jjtn000.setIRI(_trimString(t.image, 1));}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PrefixDecl() :
{/*@bgen(jjtree) PrefixDecl */
  ASTPrefixDecl jjtn000 = new ASTPrefixDecl(JJTPREFIXDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token prefix; }
{/*@bgen(jjtree) PrefixDecl */
    try {
/*@egen*/
    <PREFIX> prefix = <PNAME_NS> IRI()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        // Remove trailing colon from prefix
        String prefixStr = prefix.image;
        prefixStr = prefixStr.substring(0, prefixStr.length() - 1);

        jjtn000.setPrefix(prefixStr);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void Query()       :
{}
{
    (SelectQuery() | ConstructQuery() |	DescribeQuery() | AskQuery()) }

void SelectQuery() :
{/*@bgen(jjtree) SelectQuery */
  ASTSelectQuery jjtn000 = new ASTSelectQuery(JJTSELECTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SelectQuery */
    try {
/*@egen*/
    Select()
    ( DatasetClause() )*
    ( NamedSubquery() )*
    WhereClause()
    SolutionModifier()
    [BindingsClause()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SubSelect()              : // subselect does not accept dataset clauses
{/*@bgen(jjtree) SelectQuery */
  ASTSelectQuery jjtn000 = new ASTSelectQuery(JJTSELECTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SelectQuery */
    try {
/*@egen*/
    Select()
    WhereClause()
    SolutionModifier()
    [BindingsClause()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Select() :
{/*@bgen(jjtree) Select */
  ASTSelect jjtn000 = new ASTSelect(JJTSELECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Select */
    try {
/*@egen*/
    <SELECT>
    
    [
        <DISTINCT> {jjtn000.setDistinct(true);}
    |
        <REDUCED> {jjtn000.setReduced(true);}
    ]

    (
        <STAR>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { jjtn000.setWildcard(true); }
    |
        ( ProjectionElem() )+ 
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ProjectionElem() :
{/*@bgen(jjtree) ProjectionElem */
  ASTProjectionElem jjtn000 = new ASTProjectionElem(JJTPROJECTIONELEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ProjectionElem */
    try {
/*@egen*/
    Var() 
    |
    <LPAREN> Expression() <AS> Var() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ConstructQuery() :
{/*@bgen(jjtree) ConstructQuery */
  ASTConstructQuery jjtn000 = new ASTConstructQuery(JJTCONSTRUCTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstructQuery */
    try {
/*@egen*/
    Construct()
    ( DatasetClause() )*
    ( NamedSubquery() )*
    WhereClause()
    SolutionModifier()
    [BindingsClause()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Construct() :
{/*@bgen(jjtree) Construct */
  ASTConstruct jjtn000 = new ASTConstruct(JJTCONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Construct */
    try {
/*@egen*/   
    <CONSTRUCT> [ LOOKAHEAD(2) ConstructClause() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    
}

void ConstructClause()       :
{}
{
    // Note: replaced ConstructTriples ref with equivalent TriplesBlock ref
    <LBRACE> [ TriplesBlock() ] <RBRACE>
}

void DescribeQuery() :
{/*@bgen(jjtree) DescribeQuery */
  ASTDescribeQuery jjtn000 = new ASTDescribeQuery(JJTDESCRIBEQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DescribeQuery */
    try {
/*@egen*/
    Describe()
    ( DatasetClause() )*
    ( NamedSubquery() )*
    [ WhereClause() ]
    SolutionModifier()
    [BindingsClause()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Describe() :
{/*@bgen(jjtree) Describe */
  ASTDescribe jjtn000 = new ASTDescribe(JJTDESCRIBE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Describe */
    try {
/*@egen*/
    <DESCRIBE>
    (
        <STAR>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { jjtn000.setWildcard(true); }
    |
        ( VarOrIRIref() )+
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AskQuery() :
{/*@bgen(jjtree) AskQuery */
  ASTAskQuery jjtn000 = new ASTAskQuery(JJTASKQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AskQuery */
    try {
/*@egen*/
    <ASK>
    ( DatasetClause() )*
    ( NamedSubquery() )*
    WhereClause()
    [BindingsClause()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NamedSubquery() :
{/*@bgen(jjtree) NamedSubquery */
 ASTNamedSubquery jjtn000 = new ASTNamedSubquery(JJTNAMEDSUBQUERY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) NamedSubquery */
    try {
/*@egen*/
    <WITH> <LBRACE> SelectQuery() <RBRACE> <AS> t = <VAR3>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.setName(t.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
} 

void DatasetClause() :
{/*@bgen(jjtree) DatasetClause */
  ASTDatasetClause jjtn000 = new ASTDatasetClause(JJTDATASETCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DatasetClause */
    try {
/*@egen*/
    <FROM>
    (      (        [<NAMED> {jjtn000.setNamed(true);}]
        [<VIRTUAL_GRAPH> {jjtn000.setVirtual(true);}]
        IRIref()
      )
      // Note: This appears to be an openrdf specific extension whose
      // semantics are to query the default graph.  That is what we do
      // anyway if nothing is specified. E.g., "SELECT * FROM DEFAULT"
      // and "SELECT *" will do the same thing for bigdata.
      | <DEFAULT_GRAPH> 
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void WhereClause() :
{/*@bgen(jjtree) WhereClause */
  ASTWhereClause jjtn000 = new ASTWhereClause(JJTWHERECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhereClause */
     try {
/*@egen*/
     [<WHERE>] GroupGraphPattern()/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

void BindingsClause() :
{/*@bgen(jjtree) BindingsClause */
  ASTBindingsClause jjtn000 = new ASTBindingsClause(JJTBINDINGSCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BindingsClause */
    try {
/*@egen*/
    <VALUES> DataBlock()
    // Keeping deprecated BINDINGS keyword for backward compatibility purposes
    | <BINDINGS> (Var())* <LBRACE> (BindingSet())* <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void InlineData():
{/*@bgen(jjtree) InlineData */
  ASTInlineData jjtn000 = new ASTInlineData(JJTINLINEDATA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InlineData */
    try {
/*@egen*/
    <VALUES> DataBlock()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DataBlock()       :
{}
{
     InlineDataOneVar()
   | InlineDataFull()
}

void InlineDataOneVar()       :
{}
{
    Var() <LBRACE> (SimpleBindingSet())* <RBRACE>
}

void InlineDataFull()       :
{}
{
    ( <NIL> | <LPAREN> (Var())* <RPAREN> ) <LBRACE> ( BindingSet())* <RBRACE>
}

void SimpleBindingSet()             :
{/*@bgen(jjtree) BindingSet */
  ASTBindingSet jjtn000 = new ASTBindingSet(JJTBINDINGSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BindingSet */
    try {
/*@egen*/
    BindingValue()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void BindingSet() :
{/*@bgen(jjtree) BindingSet */
  ASTBindingSet jjtn000 = new ASTBindingSet(JJTBINDINGSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BindingSet */
    try {
/*@egen*/
    <LPAREN> ( BindingValue() )* <RPAREN> | <NIL>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void BindingValue() :
{/*@bgen(jjtree) BindingValue */
  ASTBindingValue jjtn000 = new ASTBindingValue(JJTBINDINGVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BindingValue */
    try {
/*@egen*/
    IRIref()
|   RDFLiteral()
|   NumericLiteral()
|   BooleanLiteral()
|   <UNDEF>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void SolutionModifier()       :
{}
{
    [GroupClause()] [HavingClause()] [OrderClause()] [LimitOffsetClauses()]
}

void GroupClause() :
{/*@bgen(jjtree) GroupClause */
  ASTGroupClause jjtn000 = new ASTGroupClause(JJTGROUPCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GroupClause */
    try {
/*@egen*/
    <GROUP> <BY> ( GroupCondition() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void OrderClause() :
{/*@bgen(jjtree) OrderClause */
  ASTOrderClause jjtn000 = new ASTOrderClause(JJTORDERCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrderClause */
    try {
/*@egen*/
    <ORDER> <BY> ( OrderCondition() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GroupCondition() :
{/*@bgen(jjtree) GroupCondition */
  ASTGroupCondition jjtn000 = new ASTGroupCondition(JJTGROUPCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GroupCondition */
    try {
/*@egen*/
    FunctionCall()
|   BuiltInCall()
|   <LPAREN> Expression() [ <AS> Var() ] <RPAREN> 
|   Var()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void HavingClause() :
{/*@bgen(jjtree) HavingClause */
  ASTHavingClause jjtn000 = new ASTHavingClause(JJTHAVINGCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) HavingClause */
    try {
/*@egen*/
    <HAVING> Constraint()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void OrderCondition() :
{/*@bgen(jjtree) OrderCondition */
  ASTOrderCondition jjtn000 = new ASTOrderCondition(JJTORDERCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrderCondition */
    try {
/*@egen*/
    [ <ASC> | <DESC> {jjtn000.setAscending(false);}] BrackettedExpression()
|   FunctionCall()
|   BuiltInCall()
|   Var()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LimitOffsetClauses()       :
{}
{
    Limit() [ Offset() ]
|
    Offset() [ Limit() ]
}

void Limit() :
{/*@bgen(jjtree) Limit */
  ASTLimit jjtn000 = new ASTLimit(JJTLIMIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Limit */
    try {
/*@egen*/
    <LIMIT> t = <INTEGER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.setValue(Long.parseLong(t.image)); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Offset() :
{/*@bgen(jjtree) Offset */
  ASTOffset jjtn000 = new ASTOffset(JJTOFFSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Offset */
    try {
/*@egen*/
    <OFFSET> t = <INTEGER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.setValue(Long.parseLong(t.image)); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Note: Allows return of the text for the SERVICE's inner graph pattern.
Token GroupGraphPattern()                    :
{/*@bgen(jjtree) GraphPatternGroup */
 ASTGraphPatternGroup jjtn000 = new ASTGraphPatternGroup(JJTGRAPHPATTERNGROUP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token endOfPatternToken; }
{/*@bgen(jjtree) GraphPatternGroup */
    try {
/*@egen*/
    <LBRACE> 
    (
        SubSelect() 
        | 
        GraphPattern()
    ) 
    endOfPatternToken = <RBRACE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return endOfPatternToken;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
//void GroupGraphPattern() #GraphPatternGroup :
//{}
//{
//  <LBRACE> (SelectQuery() | GraphPattern()) <RBRACE>
//}

void GraphPattern()       :
{}
{
    [BasicGraphPattern()] [ GraphPatternNotTriples() [<DOT>] GraphPattern() ]
}

void BasicGraphPattern() :
{/*@bgen(jjtree) BasicGraphPattern */
  ASTBasicGraphPattern jjtn000 = new ASTBasicGraphPattern(JJTBASICGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BasicGraphPattern */
    try {
/*@egen*/
    TriplesBlock() ( FilterOrBind() [<DOT>] [TriplesBlock()] )*
|
    ( FilterOrBind() [<DOT>] [TriplesBlock()] )+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void FilterOrBind()       :
{}
{
    Filter()
    |
    NamedSubqueryInclude()
    | 
    Bind()
    |
    Let() 
}

void NamedSubqueryInclude() :
{/*@bgen(jjtree) NamedSubqueryInclude */
 ASTNamedSubqueryInclude jjtn000 = new ASTNamedSubqueryInclude(JJTNAMEDSUBQUERYINCLUDE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) NamedSubqueryInclude */
     try {
/*@egen*/
     <INCLUDE> t = <VAR3>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     { jjtn000.setName(t.image); }/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

void VarList()       :
{}
{
    <NIL>
|
    <LPAREN> Var() ( <COMMA> Var() )* <RPAREN>
}

void TriplesBlock()       :
{}
{
    // Note: recursive rule rewriten to non-recursive rule, requires lookahead
    TriplesSameSubjectPath() ( LOOKAHEAD(2) <DOT> TriplesSameSubjectPath() )* [<DOT>]
}

void TriplesTemplate()       :
{}
{
    // Note: recursive rule rewriten to non-recursive rule, requires lookahead
    TriplesSameSubject() ( LOOKAHEAD(2) <DOT> TriplesSameSubject() )* [<DOT>]
}

void GraphPatternNotTriples()       :
{}
{
    OptionalGraphPattern()
|   GroupOrUnionGraphPattern()
|   GraphGraphPattern()
|   MinusGraphPattern()
|   ServiceGraphPattern()
| 	InlineData()
}

void OptionalGraphPattern() :
{/*@bgen(jjtree) OptionalGraphPattern */
  ASTOptionalGraphPattern jjtn000 = new ASTOptionalGraphPattern(JJTOPTIONALGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptionalGraphPattern */
    try {
/*@egen*/
    // Note: does not refer GroupGraphPattern() because constraints are not limited
    // to the optional graph pattern, but can also reference the operator's LHS
    <OPTIONAL> <LBRACE> (SubSelect() | GraphPattern()) <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GraphGraphPattern() :
{/*@bgen(jjtree) GraphGraphPattern */
  ASTGraphGraphPattern jjtn000 = new ASTGraphGraphPattern(JJTGRAPHGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GraphGraphPattern */
    try {
/*@egen*/
    <GRAPH> VarOrIRIref() GroupGraphPattern()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GroupOrUnionGraphPattern()       :
{}
{
    GroupGraphPattern() [ <UNION>/*@bgen(jjtree) #UnionGraphPattern( 2) */
                                  {
                                    ASTUnionGraphPattern jjtn001 = new ASTUnionGraphPattern(JJTUNIONGRAPHPATTERN);
                                    boolean jjtc001 = true;
                                    jjtree.openNodeScope(jjtn001);
                                  }
                                  try {
/*@egen*/ GroupOrUnionGraphPattern()/*@bgen(jjtree)*/
                                  } catch (Throwable jjte001) {
                                    if (jjtc001) {
                                      jjtree.clearNodeScope(jjtn001);
                                      jjtc001 = false;
                                    } else {
                                      jjtree.popNode();
                                    }
                                    if (jjte001 instanceof RuntimeException) {
                                      throw (RuntimeException)jjte001;
                                    }
                                    if (jjte001 instanceof ParseException) {
                                      throw (ParseException)jjte001;
                                    }
                                    throw (Error)jjte001;
                                  } finally {
                                    if (jjtc001) {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                    }
                                  }
/*@egen*/                       ]
}

void MinusGraphPattern() :
{/*@bgen(jjtree) MinusGraphPattern */
  ASTMinusGraphPattern jjtn000 = new ASTMinusGraphPattern(JJTMINUSGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MinusGraphPattern */
    try {
/*@egen*/
    <MINUS_SETOPER> GroupGraphPattern()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ServiceGraphPattern() :
{/*@bgen(jjtree) ServiceGraphPattern */
  ASTServiceGraphPattern jjtn000 = new ASTServiceGraphPattern(JJTSERVICEGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ServiceGraphPattern */
    try {
/*@egen*/
    t =  <SERVICE> 
    {
    jjtn000.setBeginTokenLinePos(t.beginLine);
    jjtn000.setBeginTokenColumnPos(t.beginColumn);
    }
    [<SILENT> { jjtn000.setSilent(true); } ] 
    VarOrIRIref() 
    t = GroupGraphPattern()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    jjtn000.setEndTokenLinePos(t.beginLine);
    jjtn000.setEndTokenColumnPos(t.beginColumn);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Filter()       :
{}
{
    <FILTER> Constraint()
}

void Constraint() :
{/*@bgen(jjtree) Constraint */
  ASTConstraint jjtn000 = new ASTConstraint(JJTCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Constraint */
    try {
/*@egen*/
    BrackettedExpression()
|   BuiltInCall()
|   FunctionCall()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionCall() :
{/*@bgen(jjtree) FunctionCall */
  ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionCall */
    try {
/*@egen*/
    IRIref() ArgList()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArgList()       :
{}
{
    <NIL>
|
    <LPAREN> Expression() ( <COMMA> Expression() )* <RPAREN>
}

void TriplesSameSubject() :
{/*@bgen(jjtree) TriplesSameSubject */
  ASTTriplesSameSubject jjtn000 = new ASTTriplesSameSubject(JJTTRIPLESSAMESUBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TriplesSameSubject */
    try {
/*@egen*/
    VarOrTerm() PropertyList()
|
    TriplesNode() [PropertyList()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PropertyList() :
{/*@bgen(jjtree) PropertyList */
  ASTPropertyList jjtn000 = new ASTPropertyList(JJTPROPERTYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropertyList */
    try {
/*@egen*/
    Verb() ObjectList() [ <SEMICOLON> [PropertyList()] ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ObjectList():
{/*@bgen(jjtree) ObjectList */
  ASTObjectList jjtn000 = new ASTObjectList(JJTOBJECTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectList */
    try {
/*@egen*/
    Object() ( <COMMA> Object() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TriplesSameSubjectPath() :
{/*@bgen(jjtree) TriplesSameSubjectPath */
  ASTTriplesSameSubjectPath jjtn000 = new ASTTriplesSameSubjectPath(JJTTRIPLESSAMESUBJECTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TriplesSameSubjectPath */
    try {
/*@egen*/
// Extension for triple reference pattern.
//  VarOrTerm() PropertyListPath()
    VarOrTermOrTRefP() PropertyListPath()
    |
    TriplesNodePath() [PropertyListPath()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PropertyListPath() :
{/*@bgen(jjtree) PropertyListPath */
  ASTPropertyListPath jjtn000 = new ASTPropertyListPath(JJTPROPERTYLISTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropertyListPath */
    try {
/*@egen*/
    (VerbPath() | VerbSimple()) ObjectListPath() [<SEMICOLON> [PropertyListPath()] ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ObjectListPath()            :
{/*@bgen(jjtree) ObjectList */
  ASTObjectList jjtn000 = new ASTObjectList(JJTOBJECTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectList */
        try {
/*@egen*/
	ObjectPath() ( <COMMA> ObjectPath() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VerbPath()       :
{}
{
    Path()
}

void Path()       :
{}
{
    PathAlternative()
}

void PathAlternative() :
{/*@bgen(jjtree) PathAlternative */
  ASTPathAlternative jjtn000 = new ASTPathAlternative(JJTPATHALTERNATIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PathAlternative */
    try {
/*@egen*/
    PathSequence() ( <PIPE> PathSequence() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PathSequence() :
{/*@bgen(jjtree) PathSequence */
  ASTPathSequence jjtn000 = new ASTPathSequence(JJTPATHSEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PathSequence */
    try {
/*@egen*/
    PathElt() ( <SLASH> PathElt() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PathElt() :
{/*@bgen(jjtree) PathElt */
  ASTPathElt jjtn000 = new ASTPathElt(JJTPATHELT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PathElt */
   try {
/*@egen*/
   [<INVERSE> {jjtn000.setInverse(true); }] PathPrimary() [ PathMod() ]/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void PathPrimary()       :
{}
{
    IRIref() 
    |
    <IS_A>/*@bgen(jjtree) IRI */
           {
             ASTIRI jjtn001 = new ASTIRI(JJTIRI);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*//*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn001, true);
             jjtc001 = false;
           }
/*@egen*/ { jjtn001.setValue(RDF.TYPE.toString()); }/*@bgen(jjtree)*/
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
             }
           }
/*@egen*/     
    |
    <NOT> PathNegatedPropertySet() 
    |
    <LPAREN> Path() <RPAREN>
}

void PathNegatedPropertySet()       :
{}
{
    PathOneInPropertySet() 
    |
    <LPAREN>
    [ PathOneInPropertySet() ( <PIPE> PathOneInPropertySet() )* ]
    <RPAREN>
}

void PathOneInPropertySet() :
{/*@bgen(jjtree) PathOneInPropertySet */
  ASTPathOneInPropertySet jjtn000 = new ASTPathOneInPropertySet(JJTPATHONEINPROPERTYSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PathOneInPropertySet */
    try {
/*@egen*/
    IRIref() 
    |
    <IS_A>/*@bgen(jjtree) IRI */
           {
             ASTIRI jjtn001 = new ASTIRI(JJTIRI);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*//*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn001, true);
             jjtc001 = false;
           }
/*@egen*/ { jjtn001.setValue(RDF.TYPE.toString()); }/*@bgen(jjtree)*/
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
             }
           }
/*@egen*/     
    |
    <INVERSE> {jjtn000.setInverse(true); } ( IRIref() | <IS_A>/*@bgen(jjtree) IRI */
                                                               {
                                                                 ASTIRI jjtn002 = new ASTIRI(JJTIRI);
                                                                 boolean jjtc002 = true;
                                                                 jjtree.openNodeScope(jjtn002);
                                                               }
                                                               try {
/*@egen*//*@bgen(jjtree)*/
                                                               {
                                                                 jjtree.closeNodeScope(jjtn002, true);
                                                                 jjtc002 = false;
                                                               }
/*@egen*/ { jjtn002.setValue(RDF.TYPE.toString()); }/*@bgen(jjtree)*/
                                                               } finally {
                                                                 if (jjtc002) {
                                                                   jjtree.closeNodeScope(jjtn002, true);
                                                                 }
                                                               }
/*@egen*/      )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PathMod() :
{/*@bgen(jjtree) PathMod */
  ASTPathMod jjtn000 = new ASTPathMod(JJTPATHMOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token min;
  Token max; 
}
{/*@bgen(jjtree) PathMod */
    try {
/*@egen*/
    <STAR>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { jjtn000.setLowerBound(0);
         jjtn000.setUpperBound(Long.MAX_VALUE);
    }
    |
    <QUESTION>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { jjtn000.setLowerBound(0);
         jjtn000.setUpperBound(1); 
    }
    |
    <PLUS>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { jjtn000.setLowerBound(1);
         jjtn000.setUpperBound(Long.MAX_VALUE);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VerbSimple()       :
{}
{
    Var()
}

void Object()       :
{}
{
	GraphNode()
|   TRefPattern() // extension for triple reference patterns.
}

void ObjectPath()       :{}
{
    GraphNodePath()
}

void Verb()       :
{}
{
    VarOrIRIref()
|
    <IS_A>/*@bgen(jjtree) IRI */
           {
             ASTIRI jjtn001 = new ASTIRI(JJTIRI);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*//*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn001, true);
             jjtc001 = false;
           }
/*@egen*/ { jjtn001.setValue(RDF.TYPE.toString()); }/*@bgen(jjtree)*/
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
             }
           }
/*@egen*/     
}

void TriplesNode()       :
{}
{
    Collection()
|
    BlankNodePropertyList()
}

void TriplesNodePath()       :
{}
{
	CollectionPath()
|
	BlankNodePropertyListPath()
}

void BlankNodePropertyList() :
{/*@bgen(jjtree) BlankNodePropertyList */
  ASTBlankNodePropertyList jjtn000 = new ASTBlankNodePropertyList(JJTBLANKNODEPROPERTYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BlankNodePropertyList */
    try {
/*@egen*/
    <LBRACK> PropertyList() <RBRACK>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BlankNodePropertyListPath()                        :
{/*@bgen(jjtree) BlankNodePropertyList */
  ASTBlankNodePropertyList jjtn000 = new ASTBlankNodePropertyList(JJTBLANKNODEPROPERTYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BlankNodePropertyList */
        try {
/*@egen*/
	<LBRACK> PropertyListPath() <RBRACK>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Collection() :
{/*@bgen(jjtree) Collection */
  ASTCollection jjtn000 = new ASTCollection(JJTCOLLECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Collection */
    try {
/*@egen*/
    <LPAREN> ( GraphNode() )+ <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CollectionPath()            :
{/*@bgen(jjtree) Collection */
  ASTCollection jjtn000 = new ASTCollection(JJTCOLLECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Collection */
        try {
/*@egen*/
	<LPAREN> ( GraphNodePath() )+ <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void GraphNode()       :
{}
{
    VarOrTerm()
|
    TriplesNode()
}

void GraphNodePath()       :
{}
{
	VarOrTerm()
|
	TriplesNodePath()
}

void VarOrTerm()       :
{}
{
    Var()
|
    GraphTerm()
}

void VarOrIRIref()       :
{}
{
    Var()
|
    IRIref()
}

void Var() :
{/*@bgen(jjtree) Var */
  ASTVar jjtn000 = new ASTVar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Var */
    try {
/*@egen*/
    ( t = <VAR1> | t = <VAR2> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.setName(t.image.substring(1)); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GraphTerm()       :
{
    boolean positive = true;
}
{
    IRIref()
|
    RDFLiteral()
|
    NumericLiteral()
|
    BooleanLiteral()
|
    BlankNode()
|
    <NIL>/*@bgen(jjtree) IRI */
          {
            ASTIRI jjtn001 = new ASTIRI(JJTIRI);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*//*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn001, true);
            jjtc001 = false;
          }
/*@egen*/ {jjtn001.setValue(RDF.NIL.toString());}/*@bgen(jjtree)*/
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, true);
            }
          }
/*@egen*/     
}

void Expression()       :
{}
{
    ConditionalOrExpression()
}

void ConditionalOrExpression()       :
{}
{
    ConditionalAndExpression() [ <OR>/*@bgen(jjtree) #Or( 2) */
                                      {
                                        ASTOr jjtn001 = new ASTOr(JJTOR);
                                        boolean jjtc001 = true;
                                        jjtree.openNodeScope(jjtn001);
                                      }
                                      try {
/*@egen*/ ConditionalOrExpression()/*@bgen(jjtree)*/
                                      } catch (Throwable jjte001) {
                                        if (jjtc001) {
                                          jjtree.clearNodeScope(jjtn001);
                                          jjtc001 = false;
                                        } else {
                                          jjtree.popNode();
                                        }
                                        if (jjte001 instanceof RuntimeException) {
                                          throw (RuntimeException)jjte001;
                                        }
                                        if (jjte001 instanceof ParseException) {
                                          throw (ParseException)jjte001;
                                        }
                                        throw (Error)jjte001;
                                      } finally {
                                        if (jjtc001) {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                        }
                                      }
/*@egen*/        ]
}

void ConditionalAndExpression()       :
{}
{
    ValueLogical() [ <AND>/*@bgen(jjtree) #And( 2) */
                           {
                             ASTAnd jjtn001 = new ASTAnd(JJTAND);
                             boolean jjtc001 = true;
                             jjtree.openNodeScope(jjtn001);
                           }
                           try {
/*@egen*/ ConditionalAndExpression()/*@bgen(jjtree)*/
                           } catch (Throwable jjte001) {
                             if (jjtc001) {
                               jjtree.clearNodeScope(jjtn001);
                               jjtc001 = false;
                             } else {
                               jjtree.popNode();
                             }
                             if (jjte001 instanceof RuntimeException) {
                               throw (RuntimeException)jjte001;
                             }
                             if (jjte001 instanceof ParseException) {
                               throw (ParseException)jjte001;
                             }
                             throw (Error)jjte001;
                           } finally {
                             if (jjtc001) {
                               jjtree.closeNodeScope(jjtn001,  2);
                             }
                           }
/*@egen*/         ]
}

void ValueLogical()       :
{}
{
    RelationalExpression()
}

void RelationalExpression()       :
{}
{
    NumericExpression()
    [
        <EQ> NumericExpression()/*@bgen(jjtree) #Compare( 2) */
                                 {
                                   ASTCompare jjtn001 = new ASTCompare(JJTCOMPARE);
                                   boolean jjtc001 = true;
                                   jjtree.openNodeScope(jjtn001);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn001,  2);
                                   jjtc001 = false;
                                 }
/*@egen*/ {jjtn001.setOperator(CompareOp.EQ);}/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc001) {
                                     jjtree.closeNodeScope(jjtn001,  2);
                                   }
                                 }
/*@egen*/            
    |   <NE> NumericExpression()/*@bgen(jjtree) #Compare( 2) */
                                 {
                                   ASTCompare jjtn002 = new ASTCompare(JJTCOMPARE);
                                   boolean jjtc002 = true;
                                   jjtree.openNodeScope(jjtn002);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn002,  2);
                                   jjtc002 = false;
                                 }
/*@egen*/ {jjtn002.setOperator(CompareOp.NE);}/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc002) {
                                     jjtree.closeNodeScope(jjtn002,  2);
                                   }
                                 }
/*@egen*/            
    |   <LT> NumericExpression()/*@bgen(jjtree) #Compare( 2) */
                                 {
                                   ASTCompare jjtn003 = new ASTCompare(JJTCOMPARE);
                                   boolean jjtc003 = true;
                                   jjtree.openNodeScope(jjtn003);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn003,  2);
                                   jjtc003 = false;
                                 }
/*@egen*/ {jjtn003.setOperator(CompareOp.LT);}/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc003) {
                                     jjtree.closeNodeScope(jjtn003,  2);
                                   }
                                 }
/*@egen*/            
    |   <LE> NumericExpression()/*@bgen(jjtree) #Compare( 2) */
                                 {
                                   ASTCompare jjtn004 = new ASTCompare(JJTCOMPARE);
                                   boolean jjtc004 = true;
                                   jjtree.openNodeScope(jjtn004);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn004,  2);
                                   jjtc004 = false;
                                 }
/*@egen*/ {jjtn004.setOperator(CompareOp.LE);}/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc004) {
                                     jjtree.closeNodeScope(jjtn004,  2);
                                   }
                                 }
/*@egen*/            
    |   <GE> NumericExpression()/*@bgen(jjtree) #Compare( 2) */
                                 {
                                   ASTCompare jjtn005 = new ASTCompare(JJTCOMPARE);
                                   boolean jjtc005 = true;
                                   jjtree.openNodeScope(jjtn005);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn005,  2);
                                   jjtc005 = false;
                                 }
/*@egen*/ {jjtn005.setOperator(CompareOp.GE);}/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc005) {
                                     jjtree.closeNodeScope(jjtn005,  2);
                                   }
                                 }
/*@egen*/            
    |   <GT> NumericExpression()/*@bgen(jjtree) #Compare( 2) */
                                 {
                                   ASTCompare jjtn006 = new ASTCompare(JJTCOMPARE);
                                   boolean jjtc006 = true;
                                   jjtree.openNodeScope(jjtn006);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn006,  2);
                                   jjtc006 = false;
                                 }
/*@egen*/ {jjtn006.setOperator(CompareOp.GT);}/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc006) {
                                     jjtree.closeNodeScope(jjtn006,  2);
                                   }
                                 }
/*@egen*/            
    |/*@bgen(jjtree) #Infix( 2) */
        {
          ASTInfix jjtn007 = new ASTInfix(JJTINFIX);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
        }
        try {
/*@egen*/   In()/*@bgen(jjtree)*/
        } catch (Throwable jjte007) {
          if (jjtc007) {
            jjtree.clearNodeScope(jjtn007);
            jjtc007 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte007 instanceof RuntimeException) {
            throw (RuntimeException)jjte007;
          }
          if (jjte007 instanceof ParseException) {
            throw (ParseException)jjte007;
          }
          throw (Error)jjte007;
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007,  2);
          }
        }
/*@egen*/          
    |/*@bgen(jjtree) #Infix( 2) */
        {
          ASTInfix jjtn008 = new ASTInfix(JJTINFIX);
          boolean jjtc008 = true;
          jjtree.openNodeScope(jjtn008);
        }
        try {
/*@egen*/   NotIn()/*@bgen(jjtree)*/
        } catch (Throwable jjte008) {
          if (jjtc008) {
            jjtree.clearNodeScope(jjtn008);
            jjtc008 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte008 instanceof RuntimeException) {
            throw (RuntimeException)jjte008;
          }
          if (jjte008 instanceof ParseException) {
            throw (ParseException)jjte008;
          }
          throw (Error)jjte008;
        } finally {
          if (jjtc008) {
            jjtree.closeNodeScope(jjtn008,  2);
          }
        }
/*@egen*/          
    ]
}

void NumericExpression ()       :
{}
{
    AdditiveExpression()
}

void AdditiveExpression()       :
{}
{
    MultiplicativeExpression()
    (
      <PLUS> MultiplicativeExpression()/*@bgen(jjtree) #Math( 2) */
                                        {
                                          ASTMath jjtn001 = new ASTMath(JJTMATH);
                                          boolean jjtc001 = true;
                                          jjtree.openNodeScope(jjtn001);
                                        }
                                        try {
/*@egen*//*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.setOperator(MathOp.PLUS);}/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc001) {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                          }
                                        }
/*@egen*/         
    | <MINUS> MultiplicativeExpression()/*@bgen(jjtree) #Math( 2) */
                                         {
                                           ASTMath jjtn002 = new ASTMath(JJTMATH);
                                           boolean jjtc002 = true;
                                           jjtree.openNodeScope(jjtn002);
                                         }
                                         try {
/*@egen*//*@bgen(jjtree)*/
                                         {
                                           jjtree.closeNodeScope(jjtn002,  2);
                                           jjtc002 = false;
                                         }
/*@egen*/ {jjtn002.setOperator(MathOp.MINUS);}/*@bgen(jjtree)*/
                                         } finally {
                                           if (jjtc002) {
                                             jjtree.closeNodeScope(jjtn002,  2);
                                           }
                                         }
/*@egen*/         
    | NumericLiteralPositive()/*@bgen(jjtree) #Math( 2) */
                               {
                                 ASTMath jjtn003 = new ASTMath(JJTMATH);
                                 boolean jjtc003 = true;
                                 jjtree.openNodeScope(jjtn003);
                               }
                               try {
/*@egen*//*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn003,  2);
                                 jjtc003 = false;
                               }
/*@egen*/ {jjtn003.setOperator(MathOp.PLUS);}/*@bgen(jjtree)*/
                               } finally {
                                 if (jjtc003) {
                                   jjtree.closeNodeScope(jjtn003,  2);
                                 }
                               }
/*@egen*/         
    | NumericLiteralNegative()/*@bgen(jjtree) #Math( 2) */
                               {
                                 ASTMath jjtn004 = new ASTMath(JJTMATH);
                                 boolean jjtc004 = true;
                                 jjtree.openNodeScope(jjtn004);
                               }
                               try {
/*@egen*//*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn004,  2);
                                 jjtc004 = false;
                               }
/*@egen*/ {jjtn004.setOperator(MathOp.PLUS);}/*@bgen(jjtree)*/
                               } finally {
                                 if (jjtc004) {
                                   jjtree.closeNodeScope(jjtn004,  2);
                                 }
                               }
/*@egen*/         
    )*
}

void MultiplicativeExpression()       :
{}
{
    UnaryExpression()
    (
      <STAR> UnaryExpression()/*@bgen(jjtree) #Math( 2) */
                               {
                                 ASTMath jjtn001 = new ASTMath(JJTMATH);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
                               }
                               try {
/*@egen*//*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn001,  2);
                                 jjtc001 = false;
                               }
/*@egen*/ {jjtn001.setOperator(MathOp.MULTIPLY);}/*@bgen(jjtree)*/
                               } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  2);
                                 }
                               }
/*@egen*/         
    | <SLASH> UnaryExpression()/*@bgen(jjtree) #Math( 2) */
                                {
                                  ASTMath jjtn002 = new ASTMath(JJTMATH);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*//*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn002,  2);
                                  jjtc002 = false;
                                }
/*@egen*/ {jjtn002.setOperator(MathOp.DIVIDE);}/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002,  2);
                                  }
                                }
/*@egen*/         
    )*
}

void UnaryExpression()       :
{}
{
    <NOT>/*@bgen(jjtree) Not */
          {
            ASTNot jjtn001 = new ASTNot(JJTNOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ PrimaryExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, true);
            }
          }
/*@egen*/     
|
    [<PLUS>] PrimaryExpression()
|
    UnaryMinus() PrimaryExpression()/*@bgen(jjtree) #Math( 2) */
                                     {
                                       ASTMath jjtn002 = new ASTMath(JJTMATH);
                                       boolean jjtc002 = true;
                                       jjtree.openNodeScope(jjtn002);
                                     }
                                     try {
/*@egen*//*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn002,  2);
                                       jjtc002 = false;
                                     }
/*@egen*/ {jjtn002.setOperator(MathOp.MULTIPLY);}/*@bgen(jjtree)*/
                                     } finally {
                                       if (jjtc002) {
                                         jjtree.closeNodeScope(jjtn002,  2);
                                       }
                                     }
/*@egen*/         
}

void UnaryMinus()                 :
{/*@bgen(jjtree) NumericLiteral */
  ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NumericLiteral */
    try {
/*@egen*/
    <MINUS>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setValue("-1");
        jjtn000.setDatatype(XMLSchema.INTEGER);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PrimaryExpression()       :
{}
{
    BrackettedExpression()
|   BuiltInCall()
|   LOOKAHEAD(2) FunctionCall()
|   IRIref()
|   RDFLiteral()
|   NumericLiteral()
|   BooleanLiteral()
|   Var()
|   Aggregate()
}

void Aggregate()       :
{}
{
    Count() 
|   Sum()
|   Min()
|   Max()
|   Avg()
|   Sample()
|   GroupConcat()
}

void Count() :
{/*@bgen(jjtree) Count */
  ASTCount jjtn000 = new ASTCount(JJTCOUNT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Count */
    try {
/*@egen*/
    <COUNT> <LPAREN> [ <DISTINCT> {jjtn000.setDistinct(true);} ]
       ( <STAR> {jjtn000.setWildcard(true); } | Expression() ) <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Sum() :
{/*@bgen(jjtree) Sum */
  ASTSum jjtn000 = new ASTSum(JJTSUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Sum */
    try {
/*@egen*/
    <SUM> <LPAREN> [ <DISTINCT> {jjtn000.setDistinct(true);} ] Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Min() :
{/*@bgen(jjtree) Min */
  ASTMin jjtn000 = new ASTMin(JJTMIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Min */
    try {
/*@egen*/
    <MIN> <LPAREN> [ <DISTINCT> {jjtn000.setDistinct(true);} ] Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Max() :
{/*@bgen(jjtree) Max */
  ASTMax jjtn000 = new ASTMax(JJTMAX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Max */
    try {
/*@egen*/
    <MAX> <LPAREN> [ <DISTINCT> {jjtn000.setDistinct(true);} ] Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Avg() :
{/*@bgen(jjtree) Avg */
  ASTAvg jjtn000 = new ASTAvg(JJTAVG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Avg */
    try {
/*@egen*/
    <AVG> <LPAREN> [ <DISTINCT> {jjtn000.setDistinct(true);} ] Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Sample() :
{/*@bgen(jjtree) Sample */
  ASTSample jjtn000 = new ASTSample(JJTSAMPLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Sample */
    try {
/*@egen*/
    <SAMPLE> <LPAREN> [ <DISTINCT> {jjtn000.setDistinct(true);} ] Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GroupConcat() :
{/*@bgen(jjtree) GroupConcat */
  ASTGroupConcat jjtn000 = new ASTGroupConcat(JJTGROUPCONCAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GroupConcat */
    try {
/*@egen*/
    <GROUP_CONCAT> <LPAREN> [ <DISTINCT> {jjtn000.setDistinct(true);} ]
    Expression() [ <SEMICOLON> <SEPARATOR> <EQ> Expression() ] <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BrackettedExpression()       :
{}
{
    <LPAREN> Expression() <RPAREN>
}



void BuiltInCall()       :
{}
{
    Bound()
|   SameTerm()
|   ExistsFunc()
|   NotExistsFunc()
|   Coalesce()
|   If()
|   StringFunction()
|   NumericFunction()
|   RDFTermFunction()
|   DateTimeFunction()
|   HashFunction()
}

void StringFunction()       :
{}
{
    Substr()
|   StrLen()
|   UpperCase()
|   LowerCase()
|   StrStarts()
|   StrEnds()
|   StrBefore()
|   StrAfter()
|   Replace()
|   Concat()
|   Contains()
|   EncodeForURI()
|   LangMatches()
|   RegexExpression()
}
void NumericFunction()       :
{}
{
    Rand()
|   Abs()
|   Ceil()
|   Floor()
|   Round()
}

void RDFTermFunction()       :
{}
{
    IsIRI()
|   IsBlank()
|   IsLiteral()
|   IsNumeric()
|   BNodeFunc()
|   IRIFunc()
|   Lang()
|   Datatype()
|   Str()
|   StrDt()
|   StrLang()
|	UUID()
|	STRUUID()
}

void DateTimeFunction()       :
{}
{
    Now()
|   Year()
|   Month()
|   Day()
|   Hours()
|   Minutes()
|   Seconds()
|   Timezone()
|   Tz()
}

void HashFunction()       :
{}
{
    MD5()
|   SHA1()
|   SHA224()
|   SHA256()
|   SHA384()
|   SHA512()
}


void MD5() :
{/*@bgen(jjtree) MD5 */
  ASTMD5 jjtn000 = new ASTMD5(JJTMD5);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MD5 */
    try {
/*@egen*/
    <MD5> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SHA1() :
{/*@bgen(jjtree) SHA1 */
  ASTSHA1 jjtn000 = new ASTSHA1(JJTSHA1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SHA1 */
    try {
/*@egen*/
    <SHA1> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SHA224() :
{/*@bgen(jjtree) SHA224 */
  ASTSHA224 jjtn000 = new ASTSHA224(JJTSHA224);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SHA224 */
    try {
/*@egen*/
    <SHA224> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SHA256() :
{/*@bgen(jjtree) SHA256 */
  ASTSHA256 jjtn000 = new ASTSHA256(JJTSHA256);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SHA256 */
    try {
/*@egen*/
    <SHA256> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SHA384() :
{/*@bgen(jjtree) SHA384 */
  ASTSHA384 jjtn000 = new ASTSHA384(JJTSHA384);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SHA384 */
    try {
/*@egen*/
    <SHA384> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SHA512() :
{/*@bgen(jjtree) SHA512 */
  ASTSHA512 jjtn000 = new ASTSHA512(JJTSHA512);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SHA512 */
    try {
/*@egen*/
    <SHA512> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Now() :
{/*@bgen(jjtree) Now */
  ASTNow jjtn000 = new ASTNow(JJTNOW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Now */
    try {
/*@egen*/
    <NOW> <NIL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Year() :
{/*@bgen(jjtree) Year */
  ASTYear jjtn000 = new ASTYear(JJTYEAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Year */
    try {
/*@egen*/
    <YEAR> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Month() :
{/*@bgen(jjtree) Month */
  ASTMonth jjtn000 = new ASTMonth(JJTMONTH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Month */
    try {
/*@egen*/
    <MONTH> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Day() :
{/*@bgen(jjtree) Day */
  ASTDay jjtn000 = new ASTDay(JJTDAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Day */
    try {
/*@egen*/
    <DAY> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Hours() :
{/*@bgen(jjtree) Hours */
  ASTHours jjtn000 = new ASTHours(JJTHOURS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Hours */
    try {
/*@egen*/
    <HOURS> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Minutes() :
{/*@bgen(jjtree) Minutes */
  ASTMinutes jjtn000 = new ASTMinutes(JJTMINUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Minutes */
    try {
/*@egen*/
    <MINUTES> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Seconds() :
{/*@bgen(jjtree) Seconds */
  ASTSeconds jjtn000 = new ASTSeconds(JJTSECONDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Seconds */
    try {
/*@egen*/
    <SECONDS> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Timezone() :
{/*@bgen(jjtree) Timezone */
  ASTTimezone jjtn000 = new ASTTimezone(JJTTIMEZONE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Timezone */
    try {
/*@egen*/
    <TIMEZONE> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Tz() :
{/*@bgen(jjtree) Tz */
  ASTTz jjtn000 = new ASTTz(JJTTZ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Tz */
    try {
/*@egen*/
    <TZ> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Rand() :
{/*@bgen(jjtree) Rand */
  ASTRand jjtn000 = new ASTRand(JJTRAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Rand */
    try {
/*@egen*/
    <RAND> <NIL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Abs() :
{/*@bgen(jjtree) Abs */
  ASTAbs jjtn000 = new ASTAbs(JJTABS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Abs */
    try {
/*@egen*/
    <ABS> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Ceil() :
{/*@bgen(jjtree) Ceil */
  ASTCeil jjtn000 = new ASTCeil(JJTCEIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Ceil */
    try {
/*@egen*/
    <CEIL> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Floor() :
{/*@bgen(jjtree) Floor */
  ASTFloor jjtn000 = new ASTFloor(JJTFLOOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Floor */
    try {
/*@egen*/
    <FLOOR> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Round() :
{/*@bgen(jjtree) Round */
  ASTRound jjtn000 = new ASTRound(JJTROUND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Round */
    try {
/*@egen*/
    <ROUND> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Substr() :
{/*@bgen(jjtree) Substr */
  ASTSubstr jjtn000 = new ASTSubstr(JJTSUBSTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Substr */
    try {
/*@egen*/
    <SUBSTR> <LPAREN> Expression() <COMMA> Expression() [ <COMMA> Expression() ] <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StrLen() :
{/*@bgen(jjtree) StrLen */
  ASTStrLen jjtn000 = new ASTStrLen(JJTSTRLEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StrLen */
    try {
/*@egen*/
    <STRLEN> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void UpperCase() :
{/*@bgen(jjtree) UpperCase */
  ASTUpperCase jjtn000 = new ASTUpperCase(JJTUPPERCASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UpperCase */
    try {
/*@egen*/
    <UCASE> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LowerCase() :
{/*@bgen(jjtree) LowerCase */
  ASTLowerCase jjtn000 = new ASTLowerCase(JJTLOWERCASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LowerCase */
    try {
/*@egen*/
    <LCASE> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StrStarts() :
{/*@bgen(jjtree) StrStarts */
  ASTStrStarts jjtn000 = new ASTStrStarts(JJTSTRSTARTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StrStarts */
    try {
/*@egen*/
    <STR_STARTS> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StrEnds() :
{/*@bgen(jjtree) StrEnds */
  ASTStrEnds jjtn000 = new ASTStrEnds(JJTSTRENDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StrEnds */
    try {
/*@egen*/
    <STR_ENDS> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StrBefore() :
{/*@bgen(jjtree) StrBefore */
  ASTStrBefore jjtn000 = new ASTStrBefore(JJTSTRBEFORE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StrBefore */
    try {
/*@egen*/
    <STR_BEFORE> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StrAfter() :
{/*@bgen(jjtree) StrAfter */
  ASTStrAfter jjtn000 = new ASTStrAfter(JJTSTRAFTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StrAfter */
    try {
/*@egen*/
    <STR_AFTER> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Replace() :
{/*@bgen(jjtree) Replace */
  ASTReplace jjtn000 = new ASTReplace(JJTREPLACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Replace */
    try {
/*@egen*/
    <REPLACE> <LPAREN> Expression() <COMMA> Expression() <COMMA> Expression() [ <COMMA> Expression() ] <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Concat() :
{/*@bgen(jjtree) Concat */
  ASTConcat jjtn000 = new ASTConcat(JJTCONCAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Concat */
    try {
/*@egen*/
    <CONCAT> ArgList()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Contains() :
{/*@bgen(jjtree) Contains */
  ASTContains jjtn000 = new ASTContains(JJTCONTAINS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Contains */
    try {
/*@egen*/
    <CONTAINS> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EncodeForURI() :
{/*@bgen(jjtree) EncodeForURI */
  ASTEncodeForURI jjtn000 = new ASTEncodeForURI(JJTENCODEFORURI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EncodeForURI */
    try {
/*@egen*/
    <ENCODE_FOR_URI> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void If() :
{/*@bgen(jjtree) If */
  ASTIf jjtn000 = new ASTIf(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) If */
    try {
/*@egen*/
    <IF> <LPAREN> Expression() <COMMA> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void In() :
{/*@bgen(jjtree) In */
  ASTIn jjtn000 = new ASTIn(JJTIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) In */
    try {
/*@egen*/
    <IN> ArgList()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NotIn() :
{/*@bgen(jjtree) NotIn */
  ASTNotIn jjtn000 = new ASTNotIn(JJTNOTIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotIn */
    try {
/*@egen*/
    <NOT_IN> ArgList()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Coalesce() : 
{/*@bgen(jjtree) Coalesce */
  ASTCoalesce jjtn000 = new ASTCoalesce(JJTCOALESCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Coalesce */
    try {
/*@egen*/
    <COALESCE> <LPAREN> Expression() (<COMMA> Expression())* <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Str() :
{/*@bgen(jjtree) Str */
  ASTStr jjtn000 = new ASTStr(JJTSTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Str */
    try {
/*@egen*/
    <STR> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Lang() :
{/*@bgen(jjtree) Lang */
  ASTLang jjtn000 = new ASTLang(JJTLANG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Lang */
    try {
/*@egen*/
    <LANG> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LangMatches() :
{/*@bgen(jjtree) LangMatches */
  ASTLangMatches jjtn000 = new ASTLangMatches(JJTLANGMATCHES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LangMatches */
    try {
/*@egen*/
    <LANGMATCHES> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Datatype() :
{/*@bgen(jjtree) Datatype */
  ASTDatatype jjtn000 = new ASTDatatype(JJTDATATYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Datatype */
    try {
/*@egen*/
    <DATATYPE> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bound() :
{/*@bgen(jjtree) Bound */
  ASTBound jjtn000 = new ASTBound(JJTBOUND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bound */
    try {
/*@egen*/
    <BOUND> <LPAREN> Var() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SameTerm() :
{/*@bgen(jjtree) SameTerm */
  ASTSameTerm jjtn000 = new ASTSameTerm(JJTSAMETERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SameTerm */
    try {
/*@egen*/
    <SAMETERM> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IsIRI() :
{/*@bgen(jjtree) IsIRI */
  ASTIsIRI jjtn000 = new ASTIsIRI(JJTISIRI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IsIRI */
    try {
/*@egen*/
    <IS_IRI> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IsBlank() :
{/*@bgen(jjtree) IsBlank */
  ASTIsBlank jjtn000 = new ASTIsBlank(JJTISBLANK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IsBlank */
    try {
/*@egen*/
    <IS_BLANK> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IsLiteral() :
{/*@bgen(jjtree) IsLiteral */
  ASTIsLiteral jjtn000 = new ASTIsLiteral(JJTISLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IsLiteral */
    try {
/*@egen*/
    <IS_LITERAL> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IsNumeric() :
{/*@bgen(jjtree) IsNumeric */
  ASTIsNumeric jjtn000 = new ASTIsNumeric(JJTISNUMERIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IsNumeric */
    try {
/*@egen*/
    <IS_NUMERIC> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BNodeFunc() :
{/*@bgen(jjtree) BNodeFunc */
  ASTBNodeFunc jjtn000 = new ASTBNodeFunc(JJTBNODEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BNodeFunc */
    try {
/*@egen*/
    <BNODE> ( <NIL> | <LPAREN> Expression() <RPAREN> )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void IRIFunc() :
{/*@bgen(jjtree) IRIFunc */
  ASTIRIFunc jjtn000 = new ASTIRIFunc(JJTIRIFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IRIFunc */
    try {
/*@egen*/
    <IRI> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StrDt() :
{/*@bgen(jjtree) StrDt */
  ASTStrDt jjtn000 = new ASTStrDt(JJTSTRDT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StrDt */
    try {
/*@egen*/
    <STRDT> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StrLang() :
{/*@bgen(jjtree) StrLang */
  ASTStrLang jjtn000 = new ASTStrLang(JJTSTRLANG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StrLang */
    try {
/*@egen*/
    <STRLANG> <LPAREN> Expression() <COMMA> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void UUID() :
{/*@bgen(jjtree) UUID */
  ASTUUID jjtn000 = new ASTUUID(JJTUUID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UUID */
        try {
/*@egen*/
	<UUID> <NIL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void STRUUID() :
{/*@bgen(jjtree) STRUUID */
  ASTSTRUUID jjtn000 = new ASTSTRUUID(JJTSTRUUID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) STRUUID */
        try {
/*@egen*/
	<STRUUID> <NIL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Bind() :
{/*@bgen(jjtree) Bind */
  ASTBind jjtn000 = new ASTBind(JJTBIND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bind */
    try {
/*@egen*/
  // Note: Extension for triple pattern references.
//    <BIND> <LPAREN> Expression() <AS> Var() <RPAREN>
    <BIND> <LPAREN> ( Expression() | TRefPattern() ) <AS> Var() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// LET ( ?x := expr ) is an alternative for BIND( expr AS ?x). They do the same thing.
// TODO Handle TRefPattern() in LET.
void Let() :
{/*@bgen(jjtree) Let */
  ASTLet jjtn000 = new ASTLet(JJTLET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Let */
    try {
/*@egen*/
    <LET> <LPAREN> Var() <ASSIGN> Expression() <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RegexExpression() :
{/*@bgen(jjtree) RegexExpression */
  ASTRegexExpression jjtn000 = new ASTRegexExpression(JJTREGEXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RegexExpression */
    try {
/*@egen*/
    <REGEX> <LPAREN> Expression() <COMMA> Expression() [ <COMMA> Expression() ] <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExistsFunc() :
{/*@bgen(jjtree) ExistsFunc */
  ASTExistsFunc jjtn000 = new ASTExistsFunc(JJTEXISTSFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExistsFunc */
    try {
/*@egen*/
    <EXISTS> GroupGraphPattern()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NotExistsFunc() :
{/*@bgen(jjtree) NotExistsFunc */
  ASTNotExistsFunc jjtn000 = new ASTNotExistsFunc(JJTNOTEXISTSFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotExistsFunc */
    try {
/*@egen*/
    <NOT_EXISTS> GroupGraphPattern()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void RDFLiteral() :
{/*@bgen(jjtree) RDFLiteral */
  ASTRDFLiteral jjtn000 = new ASTRDFLiteral(JJTRDFLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RDFLiteral */
    try {
/*@egen*/
    String()
    [
        t = <LANGTAG> {jjtn000.setLang(t.image.substring(1));}
    |
        <DT_PREFIX> IRIref()
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumericLiteral()       :
{}
{
    (
        NumericLiteralUnsigned()
    |   NumericLiteralPositive()
    |   NumericLiteralNegative()
    )
}

void NumericLiteralUnsigned()                 :
{/*@bgen(jjtree) NumericLiteral */
  ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; URI datatype; }
{/*@bgen(jjtree) NumericLiteral */
    try {
/*@egen*/
    (
        t = <INTEGER> { datatype = XMLSchema.INTEGER; }
    |   t = <DECIMAL> { datatype = XMLSchema.DECIMAL; }
    |   t = <DOUBLE> { datatype = XMLSchema.DOUBLE; }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.setValue(t.image);
        jjtn000.setDatatype(datatype);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumericLiteralPositive()                 :
{/*@bgen(jjtree) NumericLiteral */
  ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; URI datatype; }
{/*@bgen(jjtree) NumericLiteral */
    try {
/*@egen*/
    (
        t = <INTEGER_POSITIVE> { datatype = XMLSchema.INTEGER; }
    |   t = <DECIMAL_POSITIVE> { datatype = XMLSchema.DECIMAL; }
    |   t = <DOUBLE_POSITIVE> { datatype = XMLSchema.DOUBLE; }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.setValue(t.image);
        jjtn000.setDatatype(datatype);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumericLiteralNegative()                 :
{/*@bgen(jjtree) NumericLiteral */
  ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; URI datatype; }
{/*@bgen(jjtree) NumericLiteral */
    try {
/*@egen*/
    (
        t = <INTEGER_NEGATIVE> { datatype = XMLSchema.INTEGER; }
    |   t = <DECIMAL_NEGATIVE> { datatype = XMLSchema.DECIMAL; }
    |   t = <DOUBLE_NEGATIVE> { datatype = XMLSchema.DOUBLE; }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.setValue(t.image);
        jjtn000.setDatatype(datatype);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BooleanLiteral()       :
{}
{/*@bgen(jjtree) True */
    {
      ASTTrue jjtn001 = new ASTTrue(JJTTRUE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/      
|/*@bgen(jjtree) False */
    {
      ASTFalse jjtn002 = new ASTFalse(JJTFALSE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/   <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/       
}

void String() :
{/*@bgen(jjtree) String */
  ASTString jjtn000 = new ASTString(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) String */
    try {
/*@egen*/
    ( t = <STRING_LITERAL1> | t= <STRING_LITERAL2> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setValue(_trimString(t.image, 1));}
|
    ( t = <STRING_LITERAL_LONG1> | t = <STRING_LITERAL_LONG2>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setValue(_trimString(t.image, 3));}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IRIref()       :
{}
{
    IRI()
|
    PrefixedName()
}

void PrefixedName()        :
{/*@bgen(jjtree) QName */
  ASTQName jjtn000 = new ASTQName(JJTQNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) QName */
    try {
/*@egen*/
    (t = <PNAME_LN> | t = <PNAME_NS>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setValue(t.image);}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BlankNode() :
{/*@bgen(jjtree) BlankNode */
  ASTBlankNode jjtn000 = new ASTBlankNode(JJTBLANKNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) BlankNode */
    try {
/*@egen*/
    t = <BLANK_NODE_LABEL>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {jjtn000.setID(t.image.substring(2));}
|
    <ANON>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IRI() :
{/*@bgen(jjtree) IRI */
  ASTIRI jjtn000 = new ASTIRI(JJTIRI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IRI */
    try {
/*@egen*/
    t = <Q_IRI_REF>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.setValue(_trimString(t.image, 1));}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/// SPARQL 1.1 Update productions

// bigdata extensions: GRAPHS, SOLUTIONS, and SolutionsRef(). 
void GraphRefAll() :
{/*@bgen(jjtree) GraphRefAll */
  ASTGraphRefAll jjtn000 = new ASTGraphRefAll(JJTGRAPHREFALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GraphRefAll */
    try {
/*@egen*/
    GraphRef() 
|   <DEFAULT_GRAPH>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.setDefault(true); }
|   <NAMED>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/         {jjtn000.setNamed(true); }
|   <ALL>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/           {jjtn000.setAllGraphs(true); jjtn000.setAllSolutions(true); }
|   <GRAPHS>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/        {jjtn000.setAllGraphs(true); }
|   LOOKAHEAD(2)
 SolutionsRef()
| <SOLUTIONS>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/    {jjtn000.setAllSolutions(true); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GraphOrDefault() :
{/*@bgen(jjtree) GraphOrDefault */
  ASTGraphOrDefault jjtn000 = new ASTGraphOrDefault(JJTGRAPHORDEFAULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GraphOrDefault */
    try {
/*@egen*/
    <DEFAULT_GRAPH>
|   [<GRAPH>] IRIref()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GraphRef()       :
{}
{ 
    <GRAPH> IRIref() 
}

// bigdata extension: either a GRAPH uri or a SOLUTIONS name.
//void GraphOrSolutionsRef() #void :
//{}
//{ 
//  (GraphRef()|SolutionsRef())
//}

// bigdata extension: A SOLUTIONS name (aka named solution set ref).
void SolutionsRef() :
{/*@bgen(jjtree) SolutionsRef */
 ASTSolutionsRef jjtn000 = new ASTSolutionsRef(JJTSOLUTIONSREF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) SolutionsRef */
    try {
/*@egen*/
    <SOLUTIONS> t = <VAR3>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {jjtn000.setName(t.image);}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/  
}

void UnparsedQuadDataBlock() :
{/*@bgen(jjtree) UnparsedQuadDataBlock */
  ASTUnparsedQuadDataBlock jjtn000 = new ASTUnparsedQuadDataBlock(JJTUNPARSEDQUADDATABLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnparsedQuadDataBlock */
    try {
/*@egen*/
    <LBRACE> {jjtn000.setDataBlock(readToMatchingBrace()); } <RBRACE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void QuadData()       :
{}
{
    <LBRACE> Quads() <RBRACE> 
}

void Quads()       :
{}
{
    [TriplesTemplate()] ( QuadsNotTriples() [<DOT>] [TriplesTemplate()] )*
}

void QuadsNotTriples() :
{/*@bgen(jjtree) QuadsNotTriples */
  ASTQuadsNotTriples jjtn000 = new ASTQuadsNotTriples(JJTQUADSNOTTRIPLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) QuadsNotTriples */
    try {
/*@egen*/
    <GRAPH> VarOrIRIref() <LBRACE> [TriplesTemplate()] <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Update()       :
{}
{
    Load()
|   Clear()
|   Drop()
|   Add()
|   Move()
|   Copy()
|   Create()
|   DropEntailments()
|   CreateEntailments()
|   EnableEntailments()
|   DisableEntailments()
|   LOOKAHEAD(2) InsertData()
|   LOOKAHEAD(2) DeleteData() 
|   LOOKAHEAD(2) DeleteWhere()
|   LOOKAHEAD(2) Modify()
}

void Load() :
{/*@bgen(jjtree) Load */
 ASTLoad jjtn000 = new ASTLoad(JJTLOAD);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) Load */
    try {
/*@egen*/
//    <LOAD> [<SILENT> {jjtThis.setSilent(true);} ] IRIref() [<INTO> GraphRef() ]
    <LOAD> 
    ( <SILENT> {jjtn000.setSilent(true);}
    | <VERIFY_DATA>         <EQ> (t=<TRUE>|t=<FALSE>) {jjtn000.verifyData=Boolean.valueOf(t.image);}
    | <PRESERVE_BNODE_IDS>  <EQ> (t=<TRUE>|t=<FALSE>) {jjtn000.preserveBNodeIDs=Boolean.valueOf(t.image);}
    | <STOP_AT_FIRST_ERROR> <EQ> (t=<TRUE>|t=<FALSE>) {jjtn000.stopAtFirstError=Boolean.valueOf(t.image);}
    | <DATATYPE_HANDLING>   <EQ> (t=<IGNORE>|t=<VERIFY>|t=<NORMALIZE>) {jjtn000.datatypeHandling=DatatypeHandling.valueOf(t.image.toUpperCase());}
    )*
    IRIref()
    [ <INTO> GraphRef() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DropEntailments() :
{/*@bgen(jjtree) DropEntailments */
  ASTDropEntailments jjtn000 = new ASTDropEntailments(JJTDROPENTAILMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DropEntailments */
    try {
/*@egen*/
    <DROP_ENTAILMENTS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CreateEntailments() :
{/*@bgen(jjtree) CreateEntailments */
  ASTCreateEntailments jjtn000 = new ASTCreateEntailments(JJTCREATEENTAILMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CreateEntailments */
    try {
/*@egen*/
    <CREATE_ENTAILMENTS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EnableEntailments() :
{/*@bgen(jjtree) EnableEntailments */
  ASTEnableEntailments jjtn000 = new ASTEnableEntailments(JJTENABLEENTAILMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnableEntailments */
    try {
/*@egen*/
    <ENABLE_ENTAILMENTS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DisableEntailments() :
{/*@bgen(jjtree) DisableEntailments */
  ASTDisableEntailments jjtn000 = new ASTDisableEntailments(JJTDISABLEENTAILMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DisableEntailments */
    try {
/*@egen*/
    <DISABLE_ENTAILMENTS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Clear() :
{/*@bgen(jjtree) Clear */
  ASTClear jjtn000 = new ASTClear(JJTCLEAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Clear */
    try {
/*@egen*/
    <CLEAR> [<SILENT> {jjtn000.setSilent(true);} ] GraphRefAll()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Drop() :
{/*@bgen(jjtree) Drop */
  ASTDrop jjtn000 = new ASTDrop(JJTDROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Drop */
    try {
/*@egen*/
    <DROP> [<SILENT> {jjtn000.setSilent(true);} ] GraphRefAll()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Add() :
{/*@bgen(jjtree) Add */
  ASTAdd jjtn000 = new ASTAdd(JJTADD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Add */
    try {
/*@egen*/
    <ADD> [<SILENT> {jjtn000.setSilent(true);} ] GraphOrDefault() <TO> GraphOrDefault()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Move() :
{/*@bgen(jjtree) Move */
  ASTMove jjtn000 = new ASTMove(JJTMOVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Move */
    try {
/*@egen*/
    <MOVE> [<SILENT> {jjtn000.setSilent(true);} ] GraphOrDefault() <TO> GraphOrDefault()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Copy() :
{/*@bgen(jjtree) Copy */
  ASTCopy jjtn000 = new ASTCopy(JJTCOPY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Copy */
    try {
/*@egen*/
    <COPY> [<SILENT> {jjtn000.setSilent(true);} ] GraphOrDefault() <TO> GraphOrDefault()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// bigdata extension: CREATE SOLUTIONS ...
void Create() :
{/*@bgen(jjtree) Create */
  ASTCreate jjtn000 = new ASTCreate(JJTCREATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Create */
    try {
/*@egen*/
    <CREATE> [<SILENT> {jjtn000.setSilent(true);} ]
     ( GraphRef()
//   | SolutionsRef() (<LBRACE> TriplesTemplate() <RBRACE>)?
     | SolutionsRef() (QuadData())?
     )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void InsertData() :
{/*@bgen(jjtree) InsertData */
  ASTInsertData jjtn000 = new ASTInsertData(JJTINSERTDATA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InsertData */
    try {
/*@egen*/
    <INSERT> <DATA> UnparsedQuadDataBlock()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DeleteData() :
{/*@bgen(jjtree) DeleteData */
  ASTDeleteData jjtn000 = new ASTDeleteData(JJTDELETEDATA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeleteData */
    try {
/*@egen*/
    <DELETE> <DATA> UnparsedQuadDataBlock()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DeleteWhere() :
{/*@bgen(jjtree) DeleteWhere */
  ASTDeleteWhere jjtn000 = new ASTDeleteWhere(JJTDELETEWHERE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeleteWhere */
    try {
/*@egen*/
    <DELETE> <WHERE> QuadData()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DeleteClause() :
{/*@bgen(jjtree) DeleteClause */
 ASTDeleteClause jjtn000 = new ASTDeleteClause(JJTDELETECLAUSE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) DeleteClause */
    try {
/*@egen*/
//    <DELETE> QuadData()
    <DELETE>
    (
      <FROM> t = <VAR3> Select()/*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn000, true);
                                   jjtc000 = false;
                                 }
/*@egen*/ {jjtn000.setName(t.image);}    
    | QuadData()
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void InsertClause() :
{/*@bgen(jjtree) InsertClause */
 ASTInsertClause jjtn000 = new ASTInsertClause(JJTINSERTCLAUSE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) InsertClause */
    try {
/*@egen*/
//    <INSERT> QuadData()
    <INSERT> (<INTO> t = <VAR3> Select()/*@bgen(jjtree)*/
                                         {
                                           jjtree.closeNodeScope(jjtn000, true);
                                           jjtc000 = false;
                                         }
/*@egen*/ {jjtn000.setName(t.image);}
     | QuadData())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void UsingClause()                :
{/*@bgen(jjtree) DatasetClause */
  ASTDatasetClause jjtn000 = new ASTDatasetClause(JJTDATASETCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DatasetClause */
    try {
/*@egen*/
    <USING> [<NAMED> {jjtn000.setNamed(true);}] IRIref()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Modify() :
{/*@bgen(jjtree) Modify */
  ASTModify jjtn000 = new ASTModify(JJTMODIFY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modify */
    try {
/*@egen*/
    [<WITH> IRIref()] 
    ( DeleteClause() [InsertClause()] | InsertClause() ) (UsingClause())* 
    <WHERE> GroupGraphPattern()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*
 * Extension for triple pattern references.
 */

void VarOrIRIrefOrIsA()       :
{}
{
    VarOrIRIref()
| 
    <IS_A>/*@bgen(jjtree) IRI */
           {
             ASTIRI jjtn001 = new ASTIRI(JJTIRI);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*//*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn001, true);
             jjtc001 = false;
           }
/*@egen*/ { jjtn001.setValue(RDF.TYPE.toString()); }/*@bgen(jjtree)*/
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
             }
           }
/*@egen*/     
}

// See VarOrTerm()
void VarOrTermOrTRefP()       :
{}
{
    Var()
|
    GraphTerm()
|
    TRefPattern()
}

// Note: The subject position is constrained to not permit a literal.
void TRefPattern() :
{/*@bgen(jjtree) TRefPattern */
  ASTTRefPattern jjtn000 = new ASTTRefPattern(JJTTREFPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TRefPattern */
  try {
/*@egen*/
  <TREF_OPEN> VarOrTermOrTRefP() VarOrIRIrefOrIsA() VarOrTermOrTRefP() <TREF_CLOSE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
} 
