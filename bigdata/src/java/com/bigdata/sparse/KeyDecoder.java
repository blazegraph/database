package com.bigdata.sparse;

import java.io.UnsupportedEncodingException;

import com.bigdata.btree.KeyBuilder;

/**
 * A utility class that can decode a key in the sparse row store returning
 * the column name, and the timestamp.
 * <p>
 * Note: There is a nul byte following the schema name and then another nul
 * byte following the primary key. The schema name MAY NOT contain nuls, but
 * the primary key MAY so you MUST know the {@link Schema} in order to know
 * how many bytes are used by the primary key. The column name follows the
 * primary key (and does not allow embedded nuls) and is followed by another
 * nul byte. Finally, the timestamp is 8 bytes and is always interpreted as
 * a long integer. Both the schema name and the column name are Unicode.
 * They are converted to bytes using <code>UTF-8</code> and MAY NOT have
 * embedded nuls. In order to provide loss less decoding, neither the schema
 * name nor the column name is NOT compressed using a Unicode collator to
 * generate an order preserving sort key.
 * 
 * @todo add decoding of the schema name, possibly in a subclass.
 * 
 * @todo add decoding of the primary key, possibly in a subclass. You can
 *       figure out which bytes are the primary key using the nul delimiters
 *       but you need the {@link Schema} to known how to decode the primary
 *       key into an application object.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
public class KeyDecoder {

    /**
     * The decoded column name.
     */
    public final String col;

    /**
     * The decoded timestamp on the column value.
     */
    public final long timestamp;

    /**
     * The decoded timestamp on the column value. The semantics of the
     * timestamp depend entirely on the application. When the application
     * provides timestamps, they are application defined long integers. When
     * the application requests auto-timestamps, they are generated by the
     * data service.
     */
    public long getTimestamp() {

        return timestamp;

    }

    public KeyDecoder(Schema schema, byte[] key, int offsetColumnName) {

        if (key == null) {

            throw new IllegalArgumentException();

        }

        /*
         * Decode the key so that we can get the column name.
         * 
         * There is a nul byte following the primary key and then all
         * bytes until the next nul are the column name (which is NOT
         * compressed using Unicode compression so that we can decode it
         * without loss).
         */
        /*final*/String col = null;
        {

            int n = 0, i;

            for (i = offsetColumnName; i < key.length; i++, n++) {

                if (key[i] == 0) {

                    byte[] bytes = new byte[n];

                    System.arraycopy(key, offsetColumnName, bytes, 0, n);

                    try {

                        col = new String(bytes, SparseRowStore.UTF8);

                        break;

                    } catch (UnsupportedEncodingException ex) {

                        throw new RuntimeException(ex);

                    }

                }

            }

            if (col == null) {

                /*
                 * Could not unpack the column name from the key!
                 */

                throw new AssertionError();

            }

            this.col = col;

            /*
             * Decode the timestamp.
             */
            timestamp = KeyBuilder.decodeLong(key, i+1);

        }

    }

}
