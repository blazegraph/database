/*

Copyright (C) SYSTAP, LLC 2006-2007.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/
package com.bigdata.sparse;

import java.io.UnsupportedEncodingException;

import com.bigdata.btree.IKeyBuilder;
import com.bigdata.btree.KeyBuilder;

/**
 * A utility class that can decode a key in the sparse row store returning the
 * column name, and the timestamp.
 * <p>
 * Note: There is a nul byte following the schema name and then another nul byte
 * following the primary key. The schema name MAY NOT contain nuls, but the
 * primary key MAY so you MUST know the {@link Schema} in order to know how many
 * bytes are used by the primary key. The column name follows the primary key
 * (and does not allow embedded nuls) and is followed by another nul byte.
 * Finally, the timestamp is 8 bytes and is always interpreted as a long
 * integer. Both the schema name and the column name are Unicode. They are
 * converted to bytes using <code>UTF-8</code> and MAY NOT have embedded nuls.
 * In order to provide loss less decoding, neither the schema name nor the
 * column name is compressed using a Unicode collator to generate an order
 * preserving sort key.
 * 
 * FIXME revisit this class in the context of
 * {@link IKeyBuilder#appendText(String, boolean, boolean)}. Write unit tests
 * to explore edge conditions and verify that all necessary fields in the key
 * can be decoded. If we do not require the ability to decode certain fields
 * then let's not kill ourselves over that.
 * 
 * @todo add decoding of the schema name, possibly in a subclass.
 * 
 * @todo add decoding of the primary key, possibly in a subclass. You can figure
 *       out which bytes are the primary key using the nul delimiters but you
 *       need the {@link Schema} to known how to decode the primary key into an
 *       application object.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
public class KeyDecoder {

    /**
     * The decoded column name.
     */
    public final String col;

    /**
     * The decoded timestamp on the column value.
     */
    public final long timestamp;

    /**
     * The decoded timestamp on the column value. The semantics of the
     * timestamp depend entirely on the application. When the application
     * provides timestamps, they are application defined long integers. When
     * the application requests auto-timestamps, they are generated by the
     * data service.
     */
    public long getTimestamp() {

        return timestamp;

    }

    public KeyDecoder(Schema schema, byte[] key, int offsetColumnName) {

        if (key == null) {

            throw new IllegalArgumentException();

        }

        /*
         * Decode the key so that we can get the column name.
         * 
         * There is a nul byte following the primary key and then all
         * bytes until the next nul are the column name (which is NOT
         * compressed using Unicode compression so that we can decode it
         * without loss).
         */
        /*final*/String col = null;
        {

            int n = 0, i;

            for (i = offsetColumnName; i < key.length; i++, n++) {

                if (key[i] == 0) {

                    byte[] bytes = new byte[n];

                    System.arraycopy(key, offsetColumnName, bytes, 0, n);

                    try {

                        col = new String(bytes, SparseRowStore.UTF8);

                        break;

                    } catch (UnsupportedEncodingException ex) {

                        throw new RuntimeException(ex);

                    }

                }

            }

            if (col == null) {

                /*
                 * Could not unpack the column name from the key!
                 */

                throw new AssertionError();

            }

            this.col = col;

            /*
             * Decode the timestamp.
             */
            timestamp = KeyBuilder.decodeLong(key, i+1);

        }

    }

}
