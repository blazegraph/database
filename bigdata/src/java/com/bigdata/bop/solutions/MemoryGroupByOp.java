/**

Copyright (C) SYSTAP, LLC 2006-2011.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package com.bigdata.bop.solutions;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.FutureTask;

import org.apache.log4j.Logger;

import com.bigdata.bop.BOp;
import com.bigdata.bop.BOpContext;
import com.bigdata.bop.BOpUtility;
import com.bigdata.bop.Constant;
import com.bigdata.bop.HashMapAnnotations;
import com.bigdata.bop.IBind;
import com.bigdata.bop.IBindingSet;
import com.bigdata.bop.IConstant;
import com.bigdata.bop.IConstraint;
import com.bigdata.bop.IValueExpression;
import com.bigdata.bop.IVariable;
import com.bigdata.bop.aggregate.IAggregate;
import com.bigdata.bop.bindingSet.ListBindingSet;
import com.bigdata.bop.engine.BOpStats;
import com.bigdata.htree.HTree;
import com.bigdata.rdf.error.SparqlTypeErrorException;
import com.bigdata.relation.accesspath.IAsynchronousIterator;
import com.bigdata.relation.accesspath.IBlockingBuffer;

/**
 * An in-memory at-once generalized aggregation operator.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id: DistinctElementFilter.java 3466 2010-08-27 14:28:04Z
 *          thompsonbry $
 * 
 *          TODO Nearly the same approach could be applied with pipelined
 *          evaluation. During each evaluation pass, any new input solutions
 *          would be pushed into the {@link HTree} used to group the solutions.
 *          On the last evaluation pass we would then scan each group in turn,
 *          computing the aggregation function. This provides a means to
 *          incrementally transfer data from the Java heap to the native heap.
 *          However, that same purpose might be served by writing an "at-once"
 *          operator whose inputs are buffered on the native heap. We just need
 *          to specify how the aggregation operator will gain access to the
 *          input solutions without copying them (alternatively, the input
 *          solutions could be buffered by an {@link HTree} which is already
 *          imposing the GROUP_BY constraint.) This is in turn very similar to
 *          breaking down the generalized aggregation operator into a GROUP_BY
 *          operator and an aggregation operator running over the {@link HTree}
 *          (and set of groups) generated by the GROUP_BY operator.
 */
public class MemoryGroupByOp extends GroupByOp {

    /**
     * 
     */
    private static final long serialVersionUID = 1L;

	private static final transient Logger log = Logger
			.getLogger(MemoryGroupByOp.class);
    
    public interface Annotations extends GroupByOp.Annotations,
            HashMapAnnotations {

	}

    /**
     * Required deep copy constructor.
     */
    public MemoryGroupByOp(final MemoryGroupByOp op) {
        super(op);
    }

    /**
     * Required shallow copy constructor.
     */
    public MemoryGroupByOp(final BOp[] args,
            final Map<String, Object> annotations) {

        super(args, annotations);

        switch (getEvaluationContext()) {
		case CONTROLLER:
			break;
		default:
			throw new UnsupportedOperationException(
					Annotations.EVALUATION_CONTEXT + "="
							+ getEvaluationContext());
		}

        assertAtOnceJavaHeapOp();
        
	}
    
    /**
     * @see Annotations#INITIAL_CAPACITY
     */
    public int getInitialCapacity() {

        return getProperty(Annotations.INITIAL_CAPACITY,
                Annotations.DEFAULT_INITIAL_CAPACITY);

    }

    /**
     * @see Annotations#LOAD_FACTOR
     */
    public float getLoadFactor() {

        return getProperty(Annotations.LOAD_FACTOR,
                Annotations.DEFAULT_LOAD_FACTOR);

    }

    public FutureTask<Void> eval(final BOpContext<IBindingSet> context) {

        return new FutureTask<Void>(new GroupByTask(this, context));
        
    }

    /**
     * Wrapper used for the solution groups in the {@link ConcurrentHashMap}.
     */
    private static class SolutionGroup {

		/** The hash code for {@link #vals}. */
		private final int hash;

        /**
         * The computed values for the groupBy value expressions in the order in
         * which they were declared.
         */
        private final IConstant<?>[] vals;

		public String toString() {
			return super.toString() + //
					"{group=" + Arrays.toString(vals) + //
					"}";
		}

        /**
         * Return a new {@link SolutionGroup} given the value expressions and
         * the binding set.
         * 
         * @param groupBy
         *            The value expressions to be computed.
         * @param bset
         *            The binding set.
         * 
         * @return The new {@link SolutionGroup} -or- <code>null</code> if any
         *         of the value expressions evaluates or a <code>null</code>
         *         -OR- throws a {@link SparqlTypeErrorException}.
         */
        static SolutionGroup newInstance(final IValueExpression<?>[] groupBy,
                final IBindingSet bset) {

            final IConstant<?>[] r = new IConstant<?>[groupBy.length];

            for (int i = 0; i < groupBy.length; i++) {

                final Object asBound;
                try {
                    asBound = groupBy[i].get(bset);
                } catch (SparqlTypeErrorException ex) {
                    // Drop solution.
                    return null;
                }
                if (asBound == null) {
                    // Drop solution.
                    return null;
                }
                @SuppressWarnings({ "rawtypes", "unchecked" })
                final IConstant<?> x = new Constant(asBound);
                r[i] = x;

            }
            return new SolutionGroup(r);
        }

        private SolutionGroup(final IConstant<?>[] vals) {
            this.vals = vals;
            this.hash = java.util.Arrays.hashCode(vals);
        }

        public int hashCode() {
            return hash;
        }

        public boolean equals(final Object o) {
            if (this == o)
                return true;
            if (!(o instanceof SolutionGroup)) {
                return false;
            }
            final SolutionGroup t = (SolutionGroup) o;
            if (vals.length != t.vals.length)
                return false;
            for (int i = 0; i < vals.length; i++) {
                if (vals[i] == t.vals[i])
                    continue;
                if (vals[i] == null)
                    return false;
                if (!vals[i].equals(t.vals[i]))
                    return false;
            }
            return true;
        }

    } // SolutionGroup

    /**
     * A multiset of solutions associated with a {@link SolutionGroup}.
     */
    private static class SolutionMultiSet {

        private List<IBindingSet> solutions = new LinkedList<IBindingSet>();

        public void add(final IBindingSet bset) {

            if(bset == null)
                throw new IllegalArgumentException();
            
            solutions.add(bset);
            
        }

    }
    
    /**
     * Task executing on the node.
     */
    static private class GroupByTask implements Callable<Void> {

        private final BOpContext<IBindingSet> context;

        private final IGroupByState groupByState;

        /**
         * A map whose keys are the computed bindings on the GROUP_BY
         * expressions and whose values are the solution multisets which fall
         * into a given group.
         */
        private final LinkedHashMap<SolutionGroup, SolutionMultiSet> map;

        private final IValueExpression<?>[] groupBy;

        private final IValueExpression<?>[] select;

        private final IConstraint[] having;

        GroupByTask(final MemoryGroupByOp op,
                final BOpContext<IBindingSet> context) {
        	
            this.context = context;

            this.groupByState = new GroupByState(//
                    (IValueExpression<?>[]) op.getRequiredProperty(GroupByOp.Annotations.SELECT), //
                    (IValueExpression<?>[]) op.getProperty(GroupByOp.Annotations.GROUP_BY), //
                    (IConstraint[]) op.getProperty(GroupByOp.Annotations.HAVING)//
            );

            this.groupBy = groupByState.getGroupByClause();

            this.select = groupByState.getSelectClause();
            
            this.having = groupByState.getHavingClause();

            // The map is only defined if a GROUP_BY clause was used.
            this.map = groupBy == null ? null
                    : new LinkedHashMap<SolutionGroup, SolutionMultiSet>(
                            op.getInitialCapacity(), op.getLoadFactor());

        }

        /**
         * Add the solution to the multiset for the appropriate group. If we can
         * not compute the GROUP_BY value expressions for a solution, then the
         * solution is dropped.
         * 
         * @param bset
         *            The solution.
         */
        private void accept(final IBindingSet bset) {

            if (groupBy == null || groupBy.length == 0)
                throw new IllegalArgumentException();

            if (bset == null)
                throw new IllegalArgumentException();

            final SolutionGroup s = SolutionGroup.newInstance(groupBy, bset);

            if (s == null) {

                // Drop the solution.

                if (log.isDebugEnabled())
                    log.debug("Dropping solution: " + bset);

                return;

            }

            SolutionMultiSet m = map.get(s);

            if (m == null) {

                map.put(s, m = new SolutionMultiSet());

            }

            // Accept the solution.
            if (log.isTraceEnabled())
                log.trace("Accepting solution: " + bset);

            m.add(bset);

        }

        public Void call() throws Exception {

			final BOpStats stats = context.getStats();

			final IAsynchronousIterator<IBindingSet[]> itr = context
					.getSource();

			final IBlockingBuffer<IBindingSet[]> sink = context.getSink();

			try {

                final List<IBindingSet> accepted = new LinkedList<IBindingSet>();

                int naccepted = 0;

                if (groupBy == null) {

                    /*
                     * Combine all solutions into a single multiset.
                     */
                    final SolutionMultiSet m = new SolutionMultiSet();
                    
                    while (itr.hasNext()) {

                        final IBindingSet[] a = itr.next();

                        stats.chunksIn.increment();
                        stats.unitsIn.add(a.length);

                        for (IBindingSet bset : a) {

                            m.add(bset);

                        }                    
                        
                    }
                    
                    // Compute the aggregate for that group.
                    final IBindingSet bset = aggregate(m.solutions);

                    if (bset != null) {

                        if (log.isDebugEnabled())
                            log.debug("output: solution=" + bset);

                        accepted.add(bset);

                        naccepted++;

                    } else {

                        if (log.isDebugEnabled())
                            log.debug("output : no solution.");
                        
                    }

                } else {

                    /*
                     * Group the solutions.
                     */
                    
                    while (itr.hasNext()) {

                        final IBindingSet[] a = itr.next();

                        stats.chunksIn.increment();
                        stats.unitsIn.add(a.length);

                        for (IBindingSet bset : a) {

                            accept(bset);

                        }

                    }

                    for (Map.Entry<SolutionGroup, SolutionMultiSet> e : map
                            .entrySet()) {

                        final SolutionMultiSet m = e.getValue();

                        // Compute the aggregate for that group.
                        final IBindingSet bset = aggregate(m.solutions);

                        if (bset != null) {
                            
                            if (log.isDebugEnabled())
                                log.debug("output: groupBy=" + e.getKey()
                                        + ", solution=" + bset);

                            accepted.add(bset);

                            naccepted++;
                            
                        } else {
                            
                            if (log.isDebugEnabled())
                                log.debug("output: groupBy=" + e.getKey()
                                        + " : dropped.");
                            
                        }

                    }

                    // discard the map.
                    map.clear();

                }

                /*
                 * Output the aggregated bindings for the accepted solutions.
                 */
                if (naccepted > 0) {

                    final IBindingSet[] b = accepted
                            .toArray(new IBindingSet[naccepted]);

                    sink.add(b);

                    // flush the output.
                    sink.flush();

                }

                // done.
                return null;

            } finally {

                sink.close();

            }

        } // call()

        /**
         * Compute the aggregate solution for a solution multiset (aka a group).
         * <ol>
         * <li>
         * 1.x Bind any values for GROUP_BY variables which will be projected
         * out by the SELECT expression on a new binding set which will
         * represent the aggregate for the group.</li>
         * <li>
         * 1.2 For each select expression in order (left-to-right), compute the
         * select expression using the appropriate column projections. (This
         * will involve a reset(), presentation of each solution for a column
         * we...</li>
         * </ol>
         * 
         * @param exprs
         *            The ordered array of {@link IValueExpression}s to be
         *            projected out of the query.
         * 
         * @return The aggregate solution -or- <code>null</code> if the solution
         *         for the group was dropped (type error or violated HAVING
         *         constraint).
         * 
         *         FIXME Javadoc edit.
         * 
         *         FIXME This needs to apply the reset()/{get(bset)},done()
         *         pattern. This needs to be done for each {@link IAggregate}
         *         function encountered during a traversal of the value
         *         expression to be computed. Only the final result reported by
         *         done() can be passed up to the parent operator and used as an
         *         input to scalar operator evaluation. The top-level expr
         *         should be a bind() to bind the result on an output solution,
         *         so this needs access to the output solution. Also, scalar
         *         variables (those declared by the GROUP_BY clause) should be
         *         directly bound on the output solution rather than scanning
         *         over all solutions within a group!
         * 
         *         FIXME We also need to handle HAVING expressions, which
         *         involve aggregates within constraints.
         * 
         *         FIXME This does not handle agg(DISTINCT) semantics.
         * 
         *         FIXME This does not handle the special COUNT(DISTINCT *)
         *         semantics.
         * 
         *         TODO Unit test with empty group (this can occur only for a
         *         query without a GROUP BY clause if there are no input
         *         solutions).
         */
        public IBindingSet aggregate(final Iterable<IBindingSet> solutions) {

            if (solutions == null) {
                // Drop empty group.
                return null;
            }
            
            /*
             * New binding set for the aggregate solution.
             */
            final IBindingSet agg = new ListBindingSet();

            /*
             * If a groupBy clause was used, bind each SELECT expression which
             * is either a bare reference to a variable declared in the GROUP_BY
             * clause or a BIND() of a reference to a variable declared in the
             * GROUP_BY clause onto a new variable name.
             * 
             * TODO Unit test [SELECT ?x AS ?y GROUP BY ?x] (rename of a
             * GROUP_BY variable).
             */
            if (groupBy != null) {
                // The first solution in the group.
                final IBindingSet aSolution = solutions.iterator().next();
                // Declared variables projected by the GROUP_BY clause (if any).
                final LinkedHashSet<IVariable<?>> groupByVars = groupByState
                        .getGroupByVars();
                // The projected SELECT expressions.
                for (IValueExpression<?> expr : select) {
                    if(expr instanceof IVariable<?>) {
                        /*
                         * SELECT ?x GROUP BY ?x
                         */
                        final IVariable<?> var = (IVariable<?>) expr;
                        // Bare variable MUST be projected by GROUP_BY clause.
                        if (!groupByVars.contains(var))
                            throw new AssertionError();
                        // Note: MUST be a binding for each groupBy var.
                        @SuppressWarnings({ "rawtypes", "unchecked" })
                        final Constant<?> val = new Constant(var.get(aSolution));
                        // Bind on solution.
                        agg.set(var, val);
                    } else if (expr instanceof IBind<?>) {
                        final IBind<?> bindExpr = (IBind<?>) expr;
                        if (bindExpr.getExpr() instanceof IVariable<?>) {
                            /*
                             * SELECT ?x AS ?y GROUP BY ?x
                             */
                            // reference to a groupBy variable.
                            final IVariable<?> gvar = (IVariable<?>) bindExpr
                                    .getExpr();
                            // Bare variable MUST be projected by GROUP_BY
                            // clause.
                            if (!groupByVars.contains(gvar))
                                throw new AssertionError();
                            // Note: MUST be binding for each groupBy var.
                            @SuppressWarnings({ "rawtypes", "unchecked" })
                            final Constant<?> val = new Constant(
                                    gvar.get(aSolution));
                            // variable to be projected out by SELECT.
                            final IVariable<?> ovar = ((IBind<?>) expr)
                                    .getVar();
                            // Bind on solution under projected var name.
                            agg.set(ovar, val);
                        }
                    }
                }
            }

            /*
             * Project SELECT expressions which are not bare references to a
             * variable projected by the GROUP_BY clause.
             */
            for (IValueExpression<?> expr : select) {
                if (expr instanceof IVariable<?>) {
                    // Variable projected by the GROUP_BY clause.
                    continue;
                }
                if (expr instanceof IBind<?>
                        && ((IBind<?>) expr).getExpr() instanceof IVariable<?>) {
                    // Bind to a variable projected by the GROUP_BY clause.
                    continue;
                }
                for (IBindingSet bset : solutions) {
                    final Object result = expr.get(bset);
                    if (log.isTraceEnabled())
                        log.trace("expr: " + expr + "=>" + result);
                }
            }
            // verify optional constraint(s) : FIXME Must compute aggregate
            // expressions in HAVING clause as well.
            if (having != null && !BOpUtility.isConsistent(having, agg)) {
                // drop this solution.
                return null;
            }
            return agg;
        }

    } // GroupByTask

}
